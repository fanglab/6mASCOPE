
"""
Test report metrics for a mapping job.
"""

import unittest
import logging

import numpy

from pbcore.io import AlignmentSet, ConsensusAlignmentSet
from pbcommand.models import FileTypes

from pysiv2.custom.base import TestReportStatistics, setUpFindAlignments

log = logging.getLogger(__name__)


class TestMappingStats(TestReportStatistics):
    """
    Compare the contents of the mapping stats report against expected values.
    This will work for both the SubreadSet and ConsensusReadSet variants of
    the report (although some tests will be skipped in the latter case).
    """
    REPORT_ID = set(["mapping_stats", "mapping_stats_ccs", "mapping_stats_hgap"]) # XXX yuck.
    TEST_ID = "mapping_stats"
    METRIC_IDS = [
        "mapped_subread_bases_n",
        "mapped_alignments_n",
        "mapped_reads_n",
        "mapped_subreads_n",
        "mapped_readlength_mean",
        "mapped_subread_concordance_mean",
        "mapped_subread_readlength_mean",
    ]
    MAX_RECORDS = 100000

    def setUp(self):
        super(TestMappingStats, self).setUp()
        setUpFindAlignments(self)

    def test_mapped_read_concordance_is_sequence_identity(self):
        """
        Verify that the subread concordance in the report corresponds to the
        sequence identity extracted by pbcore.io.
        """
        # XXX workaround for CCS+mapping jobs
        ds_type = AlignmentSet
        stat_id = "mapped_subread_concordance_mean"
        mean_id_report = self._get_stat(stat_id)
        if mean_id_report is None:
            raise unittest.SkipTest("mapped_subread_concordance_mean not "+
                                    "found in report")
        if self.alignment_file_name is None:
            ft_id = FileTypes.DS_ALIGN_CCS.file_type_id
            alignment_files = []
            for file_info in self.datastore.get_file_dict().values():
                if file_info.is_chunked:
                    continue
                if file_info.file_type_id == ft_id:
                    if file_info.file_id.startswith("pbalign"):
                        self.alignment_file_name = file_info.path
                        break
            if self.alignment_file_name is None:
                assert len(alignment_files) == 1
                self.alignment_file_name = alignment_files[0]
            ds_type = ConsensusAlignmentSet
            stat_id = "mapped_read_concordance_mean"
        identities = []
        with ds_type(self.alignment_file_name, skipCounts=True) as ds:
            if ds.numRecords > self.MAX_RECORDS:
                log.warn("{} exceeds size cutoff {}".format(ds.numRecords, self.MAX_RECORDS))
                raise unittest.SkipTest("Exceeds size cutoff")
            for bam in ds.resourceReaders():
                identities.extend(list(bam.identity))
        mean_id = numpy.round(numpy.array(identities).mean(), decimals=4)
        mean_id_report = self._get_stat(stat_id)
        self.assertAlmostEqual(mean_id, mean_id_report, places=4)

    def test_all_movies_have_mapped_reads(self):
        """
        Test that all movies included in the by-movie table have mapped reads.
        """
        for column in self.report.tables[0].columns:
            if column.id == "mapped_reads":
                self.assertTrue(all([x>0 for x in column.values]),
                                "One or more movies has no mapped reads")
                break
        else:
            self.fail("Can't find mapped reads column")

    def test_number_of_mapped_movies(self):
        """
        Test that the number of mapped movies as shown in the report is equal
        to the specified value (optional).
        """
        number_of_mapped_movies = self.expected_values.get("number_of_mapped_movies", None)
        if number_of_mapped_movies is None:
            raise unittest.SkipTest("number_of_mapped_movies not specified")
        else:
            col = self.report.tables[0].columns[0]
            self.assertEqual(len(col.values), number_of_mapped_movies + 1)
