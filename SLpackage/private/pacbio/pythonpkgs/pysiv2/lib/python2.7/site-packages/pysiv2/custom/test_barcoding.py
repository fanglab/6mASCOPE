
"""
Tests related to barcoding applications.
"""

from unittest import SkipTest
import os.path as op
import json

from pbcore.io import openDataSet
from pbcommand.models import FileTypes, DataStore
from pbcommand.pb_io import load_report_from_json

from pysiv2.custom.base import TestReportStatistics, TestValuesLoader


class TestBarcodeReport(TestReportStatistics):
    """
    Test contents of table in the barcode report; the expected column values
    should be defined in the ``barcode_report`` section of ``test_values.json``,
    e.g.::

        "barcode_report": {
            "barcode_ids": ["fwd1", "fwd2", "fwd3"],
            "number_of_reads": [15, 28, 16],
            "number_of_subreads": [101, 245, 147],
            "number_of_bases": [10123, 24680, 14694]
        }

    """

    REPORT_ID = set(["barcode", "barcode_isoseq3"])
    TEST_ID = "barcode_report"
    METRIC_IDS = ["n_barcodes", "mean_reads", "max_reads", "min_reads",
                  "mean_read_length", "mean_longest_subread_length",
                  "n_barcoded_reads", "n_unbarcoded_reads"]

    def test_barcode_names(self):
        """
        Test that the identifiers in the table column ``barcode`` are the
        expected strings.
        """
        self._compare_table_column("barcode_table", "barcode")

    def test_number_of_barcoded_reads(self):
        """
        Test that the values in the table column ``number_of_reads`` are the
        expected values.
        """
        self._compare_table_column("barcode_table", "number_of_reads")

    def test_number_of_barcoded_subreads(self):
        """
        Test that the values in the table column ``number_of_subreads`` are the
        expected values.
        """
        self._compare_table_column("barcode_table", "number_of_subreads")

    def test_number_of_barcoded_bases(self):
        """
        Test that the values in the table column ``number_of_bases`` are the
        expected values.
        """
        self._compare_table_column("barcode_table", "number_of_bases")

    def test_barcode_index(self):
        """
        Test that the identifiers in the table column ``barcode_index`` are the
        expected strings.
        """
        self._compare_table_column("barcode_table", "barcode_index")

    def test_barcode_biosample(self):
        """
        Test that the identifiers in the table column ``biosample`` are the
        expected strings.
        """
        self._compare_table_column("barcode_table", "biosample")


class TestDemultiplexedOutput(TestValuesLoader):
    """
    Various sanity checks run on the barcoded SubreadSet (or other type).
    """

    MAX_SUB_REPORTS = 16 # FIXME see SL-2951
    SUB_REPORT_ID = "pbreports.tasks.subread_stats-out-0"
    DS_FILE_TYPE = FileTypes.DS_SUBREADS

    def _get_dataset_in(self):
        # If the pipeline produces an intermediate SubreadSet, use that for
        # comparing with barcoded datasets
        for file_id, f in self.datastore.get_file_dict().iteritems():
            if f.file_id.startswith("pbcoretools.tasks.reparent"):
                return openDataSet(f.path)
        if "eid_ccs" in self.entrypoints.data:
            return openDataSet(self.entrypoints.data['eid_ccs'])
        else:
            return openDataSet(self.entrypoints.data['eid_subread'])

    def _get_demux_dataset_in(self):
        """
        Retrieve the dataset used directly as input to demultiplexing, which
        may not be the same as the pipeline input.
        """
        return self._get_dataset_in()

    def _get_dataset_out(self):
        for file_id, f in self.datastore.get_file_dict().iteritems():
            if f.file_type_id == FileTypes.DATASTORE.file_type_id:
                datastore = DataStore.load_from_json(f.path)
                for u, f2 in datastore.files.iteritems():
                    if f2.file_type_id == self.DS_FILE_TYPE.file_type_id and f2.file_id != "barcoding.tasks.lima-1":
                        yield f2.path

    def _get_services_dataset(self, ds_uuid):
        return self.service_access_layer.get_subreadset_by_id(ds_uuid)

    def test_output_dataset_is_barcoded(self):
        """
        Test that the BAM files in the output SubreadSet contain barcoding
        information.
        """
        for ss in self._get_dataset_out():
            with openDataSet(ss) as ds_out:
                self.assertTrue(ds_out.isBarcoded)

    def test_output_dataset_has_metadata(self):
        """
        Verify that metadata from the instrument are propagated to the barcoded
        dataset.
        """
        with self._get_dataset_in() as ds_in:
            for ss in self._get_dataset_out():
                with openDataSet(ss) as ds_out:
                    md_in = ds_in.metadata
                    md_out = ds_out.metadata
                    self.assertTrue(len(md_out.collections.submetadata) > 0)
                    self.assertEqual(
                        md_in.collections.submetadata[0].attrib['InstrumentName'],
                        md_out.collections.submetadata[0].attrib['InstrumentName'])

    def test_output_dataset_name(self):
        """
        Verify that the output openDataSet name is identical to the input name
        plus a modifier.
        """
        with self._get_dataset_in() as ds_in:
            for ss in self._get_dataset_out():
                with openDataSet(ss) as ds_out:
                    self.assertTrue(ds_out.name.startswith(ds_in.name))
                    self.assertNotEqual(ds_in.name, ds_out.name)
                    #self.assertTrue("barcode" in ds_out.name)
                    self.assertTrue("barcoded" in ds_out.tags)

    def test_service_dataset_metadata(self):
        """
        Compare the metadata returned by SMRT Link services for barcoded
        DataSet output files against a list of expected field values, all
        of which must be found for the test to pass.
        """
        self.skip_if_not_services_test()
        metadata_list = self.test_values.get("barcoding", {}).get("service_metadata", None)
        if metadata_list is None:
            raise SkipTest("No services metadata found")
        datasets = []
        for ss in self._get_dataset_out():
            with openDataSet(ss) as ds_out:
                ds_services = self._get_services_dataset(ds_out.uuid)
                datasets.append(ds_services)
        for labels in metadata_list:
            for ds in datasets:
                if all([labels[k] == ds[k] for k in labels.keys()]):
                    break
            else:
                self.fail("Can't find labels {l}".format(l=labels))

    def test_service_dataset_parent_uuid(self):
        self.skip_if_not_services_test()
        with self._get_demux_dataset_in() as ds_in:
            for ss in self._get_dataset_out():
                with openDataSet(ss) as ds_out:
                    ds_services = self._get_services_dataset(ds_out.uuid)
                    self.assertEqual(ds_services['parentUuid'], ds_in.uuid)

    def _get_barcode_report(self):
        for file_id, f in self.datastore.get_file_dict().iteritems():
            if f.file_type_id == FileTypes.REPORT.file_type_id:
                if f.file_id == "pbreports.tasks.barcode_isoseq3-out-0":
                    raise SkipTest("Not applicable to Iso-Seq 3 pipelines")
                elif "barcode" in f.file_id:
                    return load_report_from_json(f.path)
        self.fail("Couldn't find barcode report")

    def test_number_of_output_datasets(self):
        self.skip_if_not_services_test()
        n_datasets = 0
        for file_id, f in self.datastore.get_file_dict().iteritems():
            if f.file_id == "barcoding.tasks.lima-0":
                n_datasets += 1
        rpt = self._get_barcode_report()
        attr = {a.id:a.value for a in rpt.attributes}
        self.assertEqual(n_datasets, attr['n_barcodes'])

    def test_demuxed_dataset_reports(self):
        """
        Confirm that demuxed datasets and the subread_stats or ccs_demux_stats
        reports have a 1-to-1 correspondence.
        """
        self.skip_if_not_services_test()
        rpt = self._get_barcode_report()
        rpt_uuids = set(rpt.dataset_uuids)
        ds_uuids = []
        for ss in self._get_dataset_out():
            with openDataSet(ss) as ds_out:
                # disabled, see SL-3646
                #self.assertTrue(ds_out.uuid in rpt_uuids,
                #                "UUID {u} not listed".format(u=ds_out.uuid))
                ds_uuids.append(ds_out.uuid)
        if len(ds_uuids) > self.MAX_SUB_REPORTS:
            raise SkipTest("FIXME - exceeded max number of demuxed outputs")
        ds_uuids.sort()
        subrpt_uuids = []
        for file_id, file_info in self.datastore.get_file_dict().iteritems():
            if file_info.file_id == self.SUB_REPORT_ID:
                rpt = load_report_from_json(file_info.path)
                subrpt_uuids.extend(rpt.dataset_uuids)
        subrpt_uuids.sort()
        self.assertTrue(subrpt_uuids == ds_uuids)

    def test_demuxed_dataset_uuids(self):
        """
        Check that pre-generated UUIDs in DNABarcode tags are used in the
        output datasets.
        """
        self.skip_if_not_services_test()
        task_options = op.join(self.job_dir, "workflow", "options-task.json")
        with open(task_options) as f:
            options = json.load(f)
            use_barcode_uuids = options.get("pbcoretools.task_options.use_barcode_uuids", None)
            if use_barcode_uuids is None:
                raise SkipTest("CCS job, skipping")
        bc_uuids = {}
        with self._get_dataset_in() as ds:
            for bio_sample in ds.metadata.bioSamples:
                for dna_bc in bio_sample.DNABarcodes:
                    if dna_bc.uniqueId:
                        bc_uuids[dna_bc.name] = dna_bc.uniqueId
        if len(bc_uuids) == 0:
            raise SkipTest("No per-barcode UUIDs present in metadata")
        # note that not all barcodes will necessarily be found by lima
        for ss in self._get_dataset_out():
            with openDataSet(ss) as ds_out:
                for bio_sample in ds_out.metadata.bioSamples:
                    for dna_bc in bio_sample.DNABarcodes:
                        if dna_bc.uniqueId:
                            if use_barcode_uuids:
                                self.assertEqual(dna_bc.uniqueId,
                                                 ds_out.uuid)
                            else:
                                self.assertNotEqual(dna_bc.uniqueId,
                                                    ds_out.uuid)
