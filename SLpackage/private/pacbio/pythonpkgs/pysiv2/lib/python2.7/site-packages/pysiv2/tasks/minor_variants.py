
"""
Wrapper for handling de-multiplexing of barcoded samples in the Minor Variants
workflow.
"""

from zipfile import ZipFile
import logging
import json
import copy
import os.path as op
import os
import sys

from pbcore.io import ConsensusAlignmentSet, ConsensusReadSet
from pbcommand.models import FileTypes, SymbolTypes, ResourceTypes, get_pbparser
from pbcommand.resolver import resolve_tool_contract
from pbcommand.pb_io.tool_contract_io import write_resolved_tool_contract
from pbcommand.engine import run_cmd
from pbcommand.models.common import *
from pbcommand.cli import pbparser_runner
from pbcommand.utils import setup_log
from pbcoretools.chunking.gather import gather_zip
import pbsmrtpipe.loader

log = logging.getLogger(__name__)


class Constants(object):
    TOOL_ID = "pysiv2.tasks.minor_variants"
    VERSION = "0.3"
    DRIVER_EXE = "python -m pysiv2.tasks.minor_variants --resolved-tool-contract"

    FUSE_ID = "minorseq.tasks.fuse"
    CLERIC_ID = "minorseq.tasks.cleric"
    JULIET_ID = "minorseq.tasks.juliet"
    PBALIGN_ID = "pbalign.tasks.align_minorvariants"


def get_parser():
    p = get_pbparser(Constants.TOOL_ID,
                     Constants.VERSION,
                     "Minor Variants analysis",
                     __doc__,
                     Constants.DRIVER_EXE,
                     is_distributed=True,
                     nproc=SymbolTypes.MAX_NPROC,
                     resource_types=(ResourceTypes.TMP_DIR,))
    p.add_input_file_type(FileTypes.DS_ALIGN_CCS, "aligned_ccs",
                          "Aligned CCS Reads", "ConsensusAlignmentSet XML")
    p.add_input_file_type(FileTypes.DS_REF, "reference",
                          "Reference", "ReferenceSet XML")
    p.add_input_file_type(FileTypes.DS_CCS, "ccs_unmapped",
                          "Unmapped CCS reads", "ConsensusReadSet XML")
    p.add_output_file_type(FileTypes.JSON, "json_out", "JSON Results",
                           "JSON results", "juliet_report")
    p.add_output_file_type(FileTypes.ZIP, "reported_variants_per_barcode", "Minor Variants HTML Reports",
                           "Tarball of HTML reports", "juliet_report")
    rtasks, _, _, _ = pbsmrtpipe.loader.load_all()
    for opt in rtasks["minorseq.tasks.juliet"].option_schemas:
        add_opt_func = None
        default_value = opt.default
        if isinstance(opt, PacBioBooleanOption):
            add_opt_func = p.tool_contract_parser.add_boolean
        elif isinstance(opt, PacBioFloatOption):
            add_opt_func = p.tool_contract_parser.add_float
        elif isinstance(opt, PacBioIntOption):
            add_opt_func = p.tool_contract_parser.add_int
        elif isinstance(opt, PacBioStringOption):
            add_opt_func = p.tool_contract_parser.add_str
            default_value = str(opt.default)
        if add_opt_func is not None:
            add_opt_func(opt.option_id, opt.option_id, default_value,
                         opt.name, opt.description)
            continue
        elif isinstance(opt, PacBioStringChoiceOption):
            add_opt_func = p.tool_contract_parser.add_choice_str
        elif isinstance(opt, PacBioIntChoiceOption):
            add_opt_func = p.tool_contract_parser.add_choice_int
        elif isinstance(opt, PacBioFloatChoiceOption):
            add_opt_func = p.tool_contract_parser.add_choice_float
        if add_opt_func is not None:
            add_opt_func(opt.option_id, opt.option_id, opt.choices, opt.name,
                         opt.description, opt.default)
        else:
            raise TypeError("Can't process parameters of type '{t}'".format(
                            t=type(opt).__name__))
    return p


def _run_task(dir_name, tool_contract, input_files, tmp_dir, max_nproc, tool_options, log_level="INFO"):
    base_dir = os.getcwd()
    try:
        if not op.exists(dir_name):
            os.makedirs(dir_name)
        os.chdir(dir_name)
        rtc = resolve_tool_contract(
            tool_contract=tool_contract,
            input_files=input_files,
            root_output_dir=os.getcwd(),
            root_tmp_dir=tmp_dir,
            max_nproc=max_nproc,
            tool_options=tool_options,
            is_distributable=False,
            log_level=log_level)
        write_resolved_tool_contract(rtc, "resolved-tool-contract.json")
        cmd = "{e} resolved-tool-contract.json".format(e=rtc.driver.driver_exe)
        exit_code = 0
        with open("stdout", "w") as stdout:
            with open("stderr", "w") as stderr:
                result = run_cmd(cmd, stdout, stderr)
                exit_code = result.exit_code
        if exit_code != 0:
            raise RuntimeError("'{c}' failed with exit code {e} in directory {d}: {o}".format(c=cmd, e=result.exit_code, d=os.getcwd(), o=open("stderr").read()))
        return rtc
    finally:
        os.chdir(base_dir)


def julietflow_demultiplexed(rtc, barcode_label):
    """
    Run Minor Variants analysis tools (fuse, realignment, cleric, juliet) on
    what is assumed to be a single-sample input, starting from a resolved tool
    contract.
    """
    rtasks, _, _, _ = pbsmrtpipe.loader.load_all()
    base_dir= os.getcwd()
    # FIXME pbcommand bug - str params will have unicode values, which crashes
    # resolve_tool_contract
    tool_options = {}
    for key, value in rtc.task.options.iteritems():
        if isinstance(value, basestring):
            value = str(value)
        tool_options[key] = value
    def __run_task(subdir, tool_id, input_files):
        return _run_task(
            dir_name=op.join(base_dir, subdir),
            tool_contract=rtasks[tool_id].tool_contract,
            input_files=input_files,
            tmp_dir=rtc.task.tmpdir_resources[0].path,
            max_nproc=rtc.task.nproc,
            tool_options=tool_options,
            log_level=rtc.task.log_level)
    alignments = rtc.task.input_files[0]
    reference = rtc.task.input_files[1]
    unmapped = rtc.task.input_files[2]
    rtc_fuse = __run_task("fuse", Constants.FUSE_ID, [alignments])
    reference_new = rtc_fuse.task.output_files[0]
    rtc_pbalign = __run_task("pbalign", Constants.PBALIGN_ID,
                            [unmapped, reference_new])
    alignments_new = rtc_pbalign.task.output_files[0]
    rtc_cleric = __run_task("cleric", Constants.CLERIC_ID,
                           [alignments_new, reference, reference_new])
    alignments_cleric = rtc_cleric.task.output_files[0]
    rtc_juliet = __run_task("juliet", Constants.JULIET_ID, [alignments_cleric])
    html_file = rtc_juliet.task.output_files[0]
    json_file = rtc_juliet.task.output_files[1]
    zip_file = op.join(base_dir, "reported_variants_barcode_{l}.zip".format(l=barcode_label))
    with ZipFile(zip_file, "w") as zip_out:
        zip_out.write(html_file, arcname="reported_variants_barcode_{l}.html".format(l=barcode_label))
    return [zip_file, json_file]


def merge_json_dicts(outputs, output_file):
    all_samples = {}
    for label, (html_out, json_out) in outputs:
        with open(json_out) as json_in:
            d = json.loads(json_in.read())
            all_samples[label] = d
    with open(output_file, "w") as out:
        out.write(json.dumps(all_samples))


def run_rtc(rtc):
    output_dir = op.dirname(rtc.task.output_files[0])
    os.chdir(output_dir)
    with ConsensusAlignmentSet(rtc.task.input_files[0], strict=True) as ds:
        outputs = []
        if ds.isBarcoded:
            dss = ds.split(barcodes=True)
            log.info("Dataset is barcoded, running {n} sub-tasks".format(
                     n=len(dss)))
            for bc_ds in dss:
                bcs = list(set(zip(bc_ds.index.bcForward, bc_ds.index.bcReverse)))
                assert len(bcs) == 1
                label = "{f}--{r}".format(f=bcs[0][0], r=bcs[0][1])
                log.info("Processing barcode {l}".format(l=label))
                os.mkdir(label)
                try:
                    os.chdir(label)
                    ds_aln_bc = op.join(os.getcwd(),
                        "sample_{l}.consensusalignmentset.xml".format(l=label))
                    ds_ccs_bc = op.join(os.getcwd(),
                        "sample_{l}.consensusreadset.xml".format(l=label))
                    bc_ds.write(ds_aln_bc)
                    with ConsensusReadSet(rtc.task.input_files[2]) as ds_ccs:
                        ds_ccs.filters = bc_ds.filters
                        ds_ccs.newUuid()
                        ds_ccs.write(ds_ccs_bc)
                    log.info("ConsensusAlignmentSet is {f}".format(f=ds_aln_bc))
                    log.info("ConsensusReadSet is {f}".format(f=ds_ccs_bc))
                    rtc_bc = copy.deepcopy(rtc)
                    rtc_bc.task.input_files[0] = ds_aln_bc
                    rtc_bc.task.input_files[2] = ds_ccs_bc
                    outputs.append((label, julietflow_demultiplexed(rtc_bc, label)))
                finally:
                    os.chdir(output_dir)
        else:
            log.info("No barcodes, running as single sample")
            outputs.append(("NA", julietflow_demultiplexed(rtc, "all")))
        merge_json_dicts(outputs, rtc.task.output_files[0])
        tarballs = [t for label, (t,j) in outputs]
        gather_zip(tarballs, rtc.task.output_files[1])
    return 0


def run_args(args):
    raise NotImplementedError("This program only accepts resolved tool contract input")


def main(argv=sys.argv):
    return pbparser_runner(argv[1:],
                           get_parser(),
                           run_args,
                           run_rtc,
                           log,
                           setup_log)


if __name__ == "__main__":
    sys.exit(main(sys.argv))
