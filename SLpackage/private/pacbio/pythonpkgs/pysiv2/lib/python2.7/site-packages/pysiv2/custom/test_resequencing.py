
"""
Test various outputs of resequencing jobs.
"""

from collections import defaultdict
from unittest import SkipTest
import logging
import json
import os

from pbcommand.models import FileTypes
from pbcore.io import GffReader

from pysiv2.custom.base import (TestFilesWereGenerated,
                                TestReportStatistics,
                                TestStatisticsBase, TestBase)


log = logging.getLogger(__name__)


class TestResequencingOutput(TestFilesWereGenerated):
    """
    Test that the enumerated tasks and output file types appropriate to
    resequencing jobs exist in the datastore.
    """
    TASK_IDS = ["pbreports.tasks.summarize_coverage",
                "pbreports.tasks.mapping_stats",
                "pbreports.tasks.coverage_report",
                "pbreports.tasks.top_variants",
                "pbreports.tasks.variants_report"]
    FILE_TYPES = [FileTypes.GFF, FileTypes.REPORT, FileTypes.REPORT,
                  FileTypes.REPORT, FileTypes.REPORT]


# XXX not to be confused with TestVariantCallerOutput in test_variants.py
class TestVariantsReport(TestReportStatistics):
    """
    Test attribute values in the `variants` report against expected values.
    """
    REPORT_ID = "variants"
    TEST_ID = "variants"
    METRIC_IDS = [
        "weighted_mean_concordance",
        "weighted_mean_bases_called",
        "mean_contig_length",
        "weighted_mean_coverage",
    ]


class TestSummarizeConsensus(TestStatisticsBase):
    """
    Validate contents of the GFF file output by summarizeConsensus after
    variant calling.
    """
    TEST_ID = "summarize_consensus"
    METRIC_IDS = [
        "n_deletions", "n_insertions", "n_substitutions",
    ]

    @classmethod
    def getMetrics(cls):
        cls.consensus_summary_gff = cls.coverage_summary_gff = None
        for file_id, file_info in cls.datastore.get_file_dict().iteritems():
            if file_info.file_type_id == FileTypes.GFF.file_type_id:
                if "summarize_consensus" in file_info.file_id:
                    cls.consensus_summary_gff = file_info.path
                elif "summarize_coverage" in file_info.file_id:
                    cls.coverage_summary_gff = file_info.path
        cls.consensus_records = []
        cls.coverage_records = []
        if cls.consensus_summary_gff is not None:
            for MID in cls.METRIC_IDS:
                cls.metric_dict[MID] = 0
            with GffReader(cls.consensus_summary_gff) as f:
                for rec in f:
                    cls.consensus_records.append(rec)
                    a = rec.attributes
                    cls.metric_dict["n_deletions"] += int(a["del"])
                    cls.metric_dict["n_insertions"] += int(a["ins"])
                    cls.metric_dict["n_substitutions"] += int(a["sub"])
            with GffReader(cls.coverage_summary_gff) as f:
                cls.coverage_records.extend([ rec for rec in f ])

    def test_summary_gff_consistency(self):
        """
        Check that the GFF files output by summarizeCoverage and
        summarizeConsensus are consistent with each other.
        """
        if self.consensus_summary_gff is None:
            raise SkipTest("Can't find summarize_consensus output")
        self.assertTrue(len(self.consensus_records) > 0)
        self.assertEqual(len(self.consensus_records),
                         len(self.coverage_records))
        for rec1, rec2 in zip(self.coverage_records, self.consensus_records):
            attr1 = set(rec1.attributes.keys())
            attr2 = set(rec2.attributes.keys())
            self.assertTrue(attr2.issuperset(attr1),
                            "attr1: {a}\nattr2: {b}".format(a=attr1,
                                                            b=attr2))
            self.assertEqual(rec1.seqid, rec2.seqid)
            self.assertEqual(rec1.start, rec2.start)
            self.assertEqual(rec1.gaps, rec2.gaps)
            self.assertEqual(rec1.cov, rec2.cov)
            self.assertEqual(rec1.cov2, rec2.cov2)
