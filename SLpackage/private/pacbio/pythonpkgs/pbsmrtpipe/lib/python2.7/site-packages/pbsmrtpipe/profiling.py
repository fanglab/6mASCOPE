from __future__ import absolute_import, division, print_function

import logging
import os
import csv
import datetime
import platform

from pbcommand.models.report import Attribute

from pbsmrtpipe.utils import log_timing

HAS_PS_UTILS = False

try:
    import psutil
    HAS_PS_UTILS = True
except ImportError:
    pass

_PLATFORM = platform.system()

__all__ = ['TaskProfiler', 'NullTaskProfiler', 'HAS_PS_UTILS', 'convert_profile_snapshot_to_attributes',
           'get_profiler_if_configured']

log = logging.getLogger(__name__)
slog = logging.getLogger('status.' + __name__)


def _profile_process_by_id(pid):
    try:
        return _profile_process_by_id_or_raise(pid)
    except Exception:
        # Maybe the process does not exist yet,
        # or maybe it already died. This handles race conditions too.
        log.exception('Failed to profile pid {}. Returning empty profile.'.format(pid))
        default_result = dict(
                pid=pid,
                parent_pid=None,
                snapshot_at=datetime.datetime.now().isoformat(),
                num_children=0,
                memory_info_rss_total_with_children=None
                )
        return default_result

def _profile_process_by_id_or_raise(pid):
    """
    :type pid: int
    :param pid: Process Id to profile
    """
    d = dict(pid=pid,
             parent_pid=None,
             snapshot_at=datetime.datetime.now().isoformat(),
             num_children=0,
             memory_info_rss_total_with_children=None
             )

    p = psutil.Process(pid) # can raise NoSuchProcess

    def with_prefix(prefix, dx):
        for k, v in dx.iteritems():
            n = prefix + k
            d[n] = v

    with p.oneshot(): # can raise, maybe?
        d['parent_pid'] = p.ppid()
        d['name'] = p.name()
        d['status'] = p.status()
        d['num_threads'] = p.num_threads()
        # doing this for filtering reasons.
        d['num_cpu_count'] = psutil.cpu_count()

        # Different OS support
        # https://psutil.readthedocs.io/en/latest/#psutil.Process.memory_full_info
        # on OSX, this will fail with AccessDenied
        if psutil.LINUX:
            m_info = p.memory_full_info()
        else:
            m_info = p.memory_info()

        with_prefix("memory_info_", m_info._asdict())

        cpu_times = p.cpu_times()
        with_prefix("cpu_times_", cpu_times._asdict())

    # Note, this is blocking if non None value is provided
    # d['cpu_percent'] = p.cpu_percent(interval=0.5)
    return d


def _profile_process_by_id_with_children(pid):
    """
    Will include the number of children
    as well as the total RSS for main process and the children
    """
    if not psutil.pid_exists(pid):
        return []

    def _to_rss(dx):
        return dx.get('memory_info_rss', 0)

    p = psutil.Process(pid)

    s0 = _profile_process_by_id(pid)

    num_children = 0
    total_rss = _to_rss(s0)

    for children in p.children(recursive=True):
        try:
            s1 = _profile_process_by_id(children.pid)
            num_children += 1
            total_rss += _to_rss(s1)
        except Exception:
            log.warning("Failed to snapshot child process {}".format(children.pid))
            pass

    s0['memory_info_rss_total_with_children'] = total_rss
    s0['num_children'] = num_children

    return [s0]


def _bootstrap_profiler_fields():
    """
    Different OS backends will have different return values.  We'll bootstrap here to get a list of
    fields that are expected from Profiler Writer
    """
    my_pid = os.getpid()
    d = _profile_process_by_id(my_pid)
    return sorted(d.keys())


LOGGED_EXCEPTION = False

class _ProfilerBase(object):

    def info(self):
        """Terse Summary of Profiler instance"""
        return ""

    def process_info(self, process_id):
        """
        Should return a summary of the process

        :rtype str
        """
        return ""

    def snapshot(self, process_id, include_children=True):
        """
        Take a snapshot(s) of the process state/usage

        :param process_id:
        :type process_id: int
        """
        pass

    def snapshot_quietly(self, process_id, include_children=True):
        """Take a snapshot and ignore any errors"""
        try:
            return self.snapshot(process_id, include_children=include_children)
        except Exception:
            global LOGGED_EXCEPTION
            if not LOGGED_EXCEPTION:
                LOGGED_EXCEPTION = True
                log.exception('Trapped error in shapshot(). Whenever this recurs, we return [] instead.')
            return []

    def close(self):
        """
        Close the Profiler
        """
        pass


class TaskProfiler(_ProfilerBase):
    """
    Write a CSV file with the snapshots profiling the process of interest
    """
    def __init__(self, output_csv, fields):
        self.fields = {f for f in fields}

        # These are the base level
        self.fields.add("pid")
        self.fields.add("snapshot_at")

        self.output_csv = output_csv
        self._output_fh = open(output_csv, 'w')
        self.writer = csv.DictWriter(self._output_fh, fieldnames=fields)
        self.writer.writeheader()
        self.num_snapshots = 0

    def info(self):
        return "{} to {}".format(repr(self), self.output_csv)

    @staticmethod
    def from_bootstrap(output_csv):
        """Load fields from call to pid"""
        profiler_fields = _bootstrap_profiler_fields()
        return TaskProfiler(output_csv, profiler_fields)

    def __repr__(self):
        _d = dict(k=self.__class__.__name__, n=self.num_snapshots)
        return "<{k} num-snapshots:{n} >".format(**_d)

    def process_info(self, process_id):
        # to avoid race, use exception model instead of psutil.pid_exists()
        try:
            p = psutil.Process(process_id)
            sx = ["Profiling process pid:{} status:{}".format(p.pid, p.status()),
                  "Profiling process  exe: {}".format(p.exe()),
                  "Profiling process args: {}".format(p.cmdline())
                  ]
            return "\n".join(sx)
        except Exception as e:
            return "Unable to get info on Process:{} Error:{}".format(process_id, e.message)

    def snapshot(self, process_id, include_children=True):
        """Returns a List of Snapshots"""
        if include_children:
            snapshots = _profile_process_by_id_with_children(process_id)
        else:
            snapshots = [_profile_process_by_id(process_id)]

        # make sure the expected keys are consistent
        for snapshot_d in snapshots:
            if set(snapshot_d.keys()) == self.fields:
                self.writer.writerow(snapshot_d)
                self.num_snapshots += 1
                self._output_fh.flush()
        if not snapshots:
            msg = "exists" if psutil.pid_exists(process_id) else "does NOT exist"
            log.warning("Process {i} {m}. Unable to successfully snapshot of process {i}".format(i=process_id, m=msg))
        return snapshots

    def close(self):
        slog.info("Closing {}".format(self.info()))
        try:
            self._output_fh.close()
        except IOError:
            pass


class NullTaskProfiler(_ProfilerBase):

    def __repr__(self):
        return "<{k} >".format(k=self.__class__.__name__)

    def info(self):
        return repr(self)


class MetricStat(object):
    """
    Compute simple metrics
    """
    def __init__(self, ix, max_value=None, num_records=0, total=0):
        # Metric id
        self.ix = ix
        self._max_value = max_value
        self._num_records = num_records
        self._total = total

    def __repr__(self):
        _d = dict(k=self.__class__.__name__, x=self.max_value, e=self.mean, r=self._num_records, i=self.ix)
        return "<{k} id:'{i}' nrecords:{r} max:{x} mean:{e} >".format(**_d)

    @property
    def max_value(self):
        return self._max_value

    @property
    def mean(self):
        if self._num_records > 0 and self._num_records > 0:
            return float(self._total) / self._num_records
        return None

    def _apply(self, numeric_value):
        self._num_records += 1
        self._total += numeric_value

        if numeric_value > self._max_value:
            self._max_value = numeric_value

        return numeric_value

    def apply(self, value):
        if isinstance(value, (int, float)):
            return self._apply(value)
        elif isinstance(value, basestring):
            try:
                x = float(value)
                return self._apply(x)
            except TypeError:
                pass

        return value

    def to_report_attributes(self):
        def _to_id(suffix_):
            return "_".join([self.ix, suffix_])

        datum = [("max", self.max_value),
                 ("mean", self.mean),
                 ("num_records", self._num_records)]

        attrs = []
        for suffix, value in datum:
            if value is not None:
                ix = _to_id(suffix)
                name = " ".join([self.ix, suffix])
                a = Attribute(ix, value, name=name)
                attrs.append(a)

        return attrs


PROFILE_ATTRIBUTE_FIELDS_DEFAULTS = ('cpu_percent', 'cpu_times_system', 'cpu_times_user', 'cpu_times_children_user',
                                     'memory_info_rss', 'memory_info_vms', 'memory_info_rss_total_with_children'
                                     'num_threads', 'num_children')


@log_timing
def convert_profile_snapshot_to_attributes(csv_path, fields=PROFILE_ATTRIBUTE_FIELDS_DEFAULTS):
    """
    Load and convert a task-profile.csv file and convert it to a list of Report Attributes
    """

    num_snapshots = 0

    stats = {s: MetricStat(s) for s in fields}

    with open(csv_path, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            for ix, stat in stats.iteritems():
                x = row.get(ix)
                if x is not None:
                    num_snapshots += 1
                    stat.apply(x)

    attributes = [Attribute("profile_num_shapshots", num_snapshots, name="Number of Raw Profile Snapshots")]
    for stat in stats.values():
        for stat_attr in stat.to_report_attributes():
            attributes.append(stat_attr)

    return attributes


def get_profiler_if_configured(profile_csv):
    """
    Load a profiler if the system is configure with psutils

    :param profile_csv: Path to the CSV
    """
    # This might not be the best design, but is motivated by centralizing the layer
    if HAS_PS_UTILS:
        profiler = TaskProfiler.from_bootstrap(profile_csv)
        slog.info("Task Profiling mode is enabled for {}.".format(profile_csv))
    else:
        slog.info("Task Profiling mode is DISABLED")
        profiler = NullTaskProfiler()
    return profiler
