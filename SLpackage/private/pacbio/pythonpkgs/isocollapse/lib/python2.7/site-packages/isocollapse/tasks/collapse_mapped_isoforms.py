#! python

"""run `python -m isocollapse.tasks.collapse_mapped_isoforms`"""
from __future__ import absolute_import

import logging
import sys
import os.path as op
import argparse

from pbcommand.models import FileTypes
from pbcommand.cli import pbparser_runner
from pbcommand.utils import setup_log

from .utils import TCP_INPUT, TCP_OUTPUT, BaseConstants, get_contract_parser_from_const
from ..__init__ import get_tcp_option_name
from ..collapsing.CollapseIsoforms import CollapseIsoformsRunner, CollapsedFiles
from ..independent import Constants as C
from ..independent.system import lnabs
from ..utils import (get_transcript_to_reads_dict_from_transcriptset,
                     get_read_length_dict_from_bam, make_report_json)


log = logging.getLogger(__name__)


class TCConstants(BaseConstants):
    """Define Tool Conctract Constants.
    Input:
        idx 0 - HQ isoforms TranscriptSet
        idx 1 - TranscriptAlignmentSet, sorted pbmm2 alignments mapping HQ transcripts to reference
        idx 2 - All isoforms TranscriptSet
        idx 3 - FLNC bam
        idx 4 - HQ isoforms FASTQ to fetch transcript prefix string
    Output:
        idx 0 - reads which can represent collapsed filtered isoforms FASTQ
        idx 1 - collapsed filtered isoforms GFF
        idx 2 - Groups TXT
        idx 3 - Abundance TXT
        idx 4 - Read Stat TXT
        idx 5 - report json
    """
    TOOL_NAME = "collapse_mapped_isoforms"
    DESCRIPTION = "Collapse HQ polished isoforms to gene families, and generate collapsed isoforms."

    INPUT_FILES = [
        TCP_INPUT(FileTypes.DS_TRANSCRIPT, 'hq_isoforms_ds',
                  'HQ Polished Isoforms TranscriptSet', 'HQ Polished Isoforms TranscriptSet'),
        TCP_INPUT(FileTypes.DS_ALIGN_TRANSCRIPT, 'transcriptaln_ds',
                  'pbmm2 TranscriptAlignmentSet Output', 'pbmm2 TranscriptAlignmentSet output'),
        TCP_INPUT(FileTypes.DS_TRANSCRIPT, 'all_isoforms_ds',
                  'Polished Isoforms TranscriptSet', 'Polished Isoforms TranscriptSet'),
        TCP_INPUT(FileTypes.BAM, 'flnc_bam', 'FLNC BAM', 'Full-Length Non-Concatemer Reads BAM'),
    ]
    OUTPUT_FILES = [
        TCP_OUTPUT(FileTypes.FASTQ, "collapsed_isoforms", "Collapsed Filtered Isoforms FASTQ",
                   "Collapsed Filtered Isoforms FASTQ", "out"),
        TCP_OUTPUT(FileTypes.GFF, "collapsed_isoforms", "Collapsed Filtered Isoforms GFF",
                   "Collapsed Filtered Isoforms GFF", "out"),
        TCP_OUTPUT(FileTypes.TXT, "collapsed_isoforms", "Group TXT", "Group TXT", "out.group"),
        TCP_OUTPUT(FileTypes.TXT, "collapsed_isoforms", "Abundance TXT", "Abundance TXT", "out.abundance"),
        TCP_OUTPUT(FileTypes.TXT, "collapsed_isoforms", "Read Stat TXT", "Read Stat TXT", "out.read_stat"),
        TCP_OUTPUT(FileTypes.JSON, "collapsed_isoforms", "Report JSON", "Report JSON", "out.report"),
    ]
    PARAMS = [C.MIN_ALN_COVERAGE, C.MIN_ALN_IDENTITY, C.MAX_FUZZY_JUNCTION, C.ALLOW_EXTRA_5EXON]


def run_main(i_hq_transcript_ds, i_transcriptaln_ds, i_all_transcript_ds, i_flnc_bam,
             output_prefix, out_isoforms, out_gff, out_group, out_abundance, out_read_stat,
             out_report_json, min_aln_coverage, min_aln_identity, max_fuzzy_junction,
             allow_extra_5exon):
    """
    Collapse input HQ isoforms to gene families, and output collapsed isoforms FASTQ, GFF, GROUP TXT.
    Make abundance file.
    Filter based on coverage.

    i_hq_transcript_ds -- HQ polished isoforms TranscriptSet
    i_transcriptaln_ds -- pbmm2 alignment mapping HQ isoformts to reference, sorted by (chromosome, start position)
    i_all_transcript_ds -- all polished isoforms TranscriptSet
    i_flnc_bam -- full length non concatemer reads in bam
    """
    log.info("Running main")
    log.debug("args: %r", locals())
    cf = CollapsedFiles(prefix=output_prefix, allow_extra_5exon=allow_extra_5exon)
    c = CollapseIsoformsRunner(isoform_filename=i_hq_transcript_ds,
                               aln_filename=i_transcriptaln_ds,
                               output_prefix=output_prefix,
                               min_aln_coverage=min_aln_coverage,
                               min_aln_identity=min_aln_identity,
                               max_fuzzy_junction=max_fuzzy_junction,
                               allow_extra_5exon=allow_extra_5exon,
                               min_flnc_coverage=C.MIN_COLLAPSE_FLNC_COVERAGE.val,
                               skip_5_exon_alt=C.SKIP_5_EXON_ALT.val)
    c.run()

    # (2) Generate read stat file and abundance file
    from ..counting import CountRunner
    transcript_to_reads_dict = get_transcript_to_reads_dict_from_transcriptset(i_all_transcript_ds)
    read_to_length_dict = get_read_length_dict_from_bam(i_flnc_bam)
    cr = CountRunner(group_filename=cf.group_fn,
                     transcript_to_reads_dict=transcript_to_reads_dict,
                     read_to_length_dict=read_to_length_dict,
                     output_read_stat_filename=cf.read_stat_fn,
                     output_abundance_filename=cf.abundance_fn)
    cr.run()

    # (3) Filter collapsed isoforms by min FL count based on abundance file.
    from ..collapsing import FilteredFiles
    from ..filtering import filter_by_count, filter_out_subsets
    fff = FilteredFiles(prefix=output_prefix, allow_extra_5exon=allow_extra_5exon,
                        min_count=C.MIN_FL_COUNT.val, filter_out_subsets=False)
    out_suffix = 'fastq'
    filter_by_count(in_group_filename=cf.group_fn, in_abundance_filename=cf.abundance_fn,
                    in_gff_filename=cf.good_gff_fn, in_rep_filename=cf.rep_fn(out_suffix),
                    transcript_to_reads_dict=transcript_to_reads_dict,
                    out_abundance_filename=fff.filtered_abundance_fn,
                    out_gff_filename=fff.filtered_gff_fn,
                    out_rep_filename=fff.filtered_rep_fn(out_suffix),
                    min_count=C.MIN_FL_COUNT.val)

    fft = FilteredFiles(prefix=output_prefix, allow_extra_5exon=allow_extra_5exon,
                        min_count=C.MIN_FL_COUNT.val, filter_out_subsets=True)

    filter_out_subsets(in_abundance_filename=fff.filtered_abundance_fn,
                       in_gff_filename=fff.filtered_gff_fn,
                       in_rep_filename=fff.filtered_rep_fn(out_suffix),
                       out_abundance_filename=fft.filtered_abundance_fn,
                       out_gff_filename=fft.filtered_gff_fn,
                       out_rep_filename=fft.filtered_rep_fn(out_suffix),
                       max_fuzzy_junction=max_fuzzy_junction)
    fff = fft

    # (5) ln outputs files
    ln_pairs = [(fff.filtered_rep_fn(out_suffix), out_isoforms),  # rep isoforms
                (fff.filtered_gff_fn, out_gff),  # gff annotation
                (fff.filtered_abundance_fn, out_abundance),  # abundance info
                (fff.group_fn, out_group),  # groups
                (fff.read_stat_fn, out_read_stat)]  # read stat info
    for src, dst in ln_pairs:
        if dst is not None:
            lnabs(src, dst)

    # (6) make report json
    make_report_json(out_isoforms, out_group, out_report_json)
    return 0


def _rtc_runner(rtc):
    """resolved tool contract runner."""
    return run_main(i_hq_transcript_ds=rtc.task.input_files[0],
                    i_transcriptaln_ds=rtc.task.input_files[1],
                    i_all_transcript_ds=rtc.task.input_files[2],
                    i_flnc_bam=rtc.task.input_files[3],
                    output_prefix=op.splitext(rtc.task.output_files[0])[0],
                    out_isoforms=rtc.task.output_files[0],
                    out_gff=rtc.task.output_files[1],
                    out_group=rtc.task.output_files[2],
                    out_abundance=rtc.task.output_files[3],
                    out_read_stat=rtc.task.output_files[4],
                    out_report_json=rtc.task.output_files[5],
                    min_aln_coverage=rtc.task.options[get_tcp_option_name(C.MIN_ALN_COVERAGE.name)],
                    min_aln_identity=rtc.task.options[get_tcp_option_name(C.MIN_ALN_IDENTITY.name)],
                    max_fuzzy_junction=rtc.task.options[get_tcp_option_name(C.MAX_FUZZY_JUNCTION.name)],
                    allow_extra_5exon=rtc.task.options[get_tcp_option_name(C.ALLOW_EXTRA_5EXON.name)])


def _args_runner(args):
    return run_main(i_hq_transcript_ds=args.hq_isoforms_ds,
                    i_transcriptaln_ds=args.transcriptaln_ds,
                    i_all_transcript_ds=args.all_isoforms_ds,
                    i_flnc_bam=args.flnc_bam,
                    output_prefix=args.output_prefix,
                    out_isoforms=args.output_prefix + '.fastq',
                    out_gff=args.output_prefix + '.gff',
                    out_group=args.output_prefix + '.group.txt',
                    out_abundance=args.output_prefix + '.abundance.txt',
                    out_read_stat=args.output_prefix + '.read_stat.txt',
                    out_report_json=args.output_prefix + '.report.json',
                    min_aln_coverage=args.min_aln_coverage,
                    min_aln_identity=args.min_aln_identity,
                    max_fuzzy_junction=args.max_fuzzy_junction,
                    allow_extra_5exon=args.allow_extra_5exon)


def main(argv=sys.argv, const=TCConstants):
    """Main"""
    const.sanity_check()
    return pbparser_runner(argv=argv[1:],
                           parser=get_contract_parser_from_const(const),
                           args_runner_func=_args_runner,
                           contract_runner_func=_rtc_runner,
                           alog=log,
                           setup_log_func=setup_log)


if __name__ == '__main__':
    sys.exit(main(argv=sys.argv))
