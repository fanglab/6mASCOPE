from __future__ import division
from .system import backticks, execute, realpath, mv, nfs_exists
from .system import lnabs as ln
import logging
import os.path as op
import sys

LOG = logging.getLogger()


def real_ppath(fn):
    """Return real 'python-style' path of a file.
    Consider files with white spaces in their paths, such as
    'res\ with\ space/out.sam' or 'res with space/out.sam',
    'res\ with\ space/out.sam' is unix-style file path.
    'res with space/out.sam' is python style file path.

    We need to convert all '\_' in path to ' ' so that python
    can handle files with space correctly, which means that
    'res\ with\ space/out.sam' will be converted to
    'res with space/out.sam'.
    """
    if fn is None:
        return None
    return op.abspath(op.expanduser(fn)).replace(r'\ ', ' ')


def get_files_from_fofn(fofn_filename):
    """Return a list of file names within a fofn file."""
    fns = []
    try:
        with open(fofn_filename, 'r') as fofn:
            for line in fofn:
                fns.append(realpath(line.strip()))
    except (IOError, OSError) as e:
        raise IOError("Failed to read from fofn file {fofn}.\n".
                      format(fofn=fofn_filename) + str(e))
    return fns


def get_files_from_file_or_fofn(filename):
    """Return a list of file names in a file or a fofn."""
    if filename.endswith(".fofn"):
        return get_files_from_fofn(filename)
    else:
        return [filename]


def is_fasta(fn):
    return fn.endswith('.fasta') or fn.endswith('.fa') or fn == 'fasta' or fn == 'fa'


def is_fastq(fn):
    return fn.endswith('.fastq') or fn.endswith('.fq') or fn == 'fastq' or fn == 'fq'


def is_sam(fn):
    return fn.endswith('.sam') or fn == 'sam'


def is_bam(fn):
    return fn.endswith('.bam') or fn == 'bam'


def is_xml(fn):
    return fn.endswith('.xml') or fn == 'xml'


def is_contigset(fn):
    return fn.endswith('.contigset.xml') or fn.endswith('.referenceset.xml')


def is_transcriptset(fn):
    return fn.endswith('.transcriptset.xml')


def is_transcriptalignmentset(fn):
    return fn.endswith('.transcriptalignmentset.xml')


def assert_fasta(fn):
    assert is_fasta(fn), 'No fasta extension: {!r}'.format(fn)


def assert_fastq(fn):
    assert is_fastq(fn), 'No fastq extension: {!r}'.format(fn)


def assert_bam(fn):
    assert is_bam(fn), 'No bam extension: {!r}'.format(fn)


def assert_xml(fn):
    assert is_xml(fn), 'No xml extension: {!r}'.format(fn)


def setup_log(alog, file_name=None, level=logging.DEBUG, str_formatter=None):
    """
    Copied from mkocher's pbreports/utils.py.
    Util function for setting up logging.

    Due to how smrtpipe logs, the default behavior is that the stdout
    is where the logging is redirected. If a file name is given the log
    will be written to that file.

    :param log: (log instance) Log instance that handlers and filters will
    be added.
    :param file_name: (str, None), Path to file. If None, stdout will be used.
    :param level: (int) logging level
    """
    if file_name is None:
        handler = logging.StreamHandler(sys.stdout)
    else:
        handler = logging.FileHandler(file_name)

    if str_formatter is None:
        str_formatter = '[%(levelname)s] %(asctime)-15s ' + \
                        '[%(name)s %(funcName)s %(lineno)d] %(message)s'

    formatter = logging.Formatter(str_formatter)
    handler.setFormatter(formatter)
    alog.addHandler(handler)
    alog.setLevel(level)


def return_false(s):
    """Always return False regardless"""
    return False


def cat_files(src, dst, no_redundant_header=False, is_header_f=return_false):
    """Concatenate files in src and save to dst.
       src --- source file names in a list
       dst --- destinate file name
       no_redundant_header --- Only keep headers in the 1st file, skip others.
       is_header_f --- return True if a line is a header, otherwise, False
    """
    if src is None or len(src) == 0:
        raise ValueError("src should contain at least one file.")
    if dst in src:
        raise IOError("Unable to cat a file and save to itself.")

    with open(real_ppath(dst), 'w') as writer:
        for idx, src_f in enumerate(src):
            with open(real_ppath(src_f), 'r') as reader:
                for line in reader:
                    if idx != 0 and no_redundant_header and is_header_f(line):
                        continue
                    writer.write(line.rstrip() + '\n')


def _replace_prefix_in_file_cmd(fn, prefix, new_prefix):
    """return sed cmd to add prefix read names in fasta and fastq.
    ...doctest:
        >>> _replace_prefix_in_file_cmd('input.file', '>', 'new_prefix')
        "sed -i 's/^>/new_prefix/g' input.file"
    """
    # no special characters allowed
    charset = string.digits + string.letters + '|_>@'
    assert all(c in charset for c in prefix + new_prefix)
    return """sed -i 's/^{p}/{new_p}/g' {f}""".format(p=prefix, new_p=new_prefix, f=fn)


import random
import string
SAMPLE_ALPHABETS = string.digits + string.letters


def generate_random_sample_str():
    """Generate a random sample string, e.g., 'sample1234567'
    Note that sample name provided by users does not have to start with 'sample' prefix.
    """
    return 'sample' + ''.join(random.choice(SAMPLE_ALPHABETS) for _ in range(0, 8))


def match_sample_pattern(s):
    """Return True if all characters are either digits or letters.
    ...doctest:
        >>> match_sample_pattern('_')
        False
    """
    return s and all([(c in SAMPLE_ALPHABETS) for c in s])


def check_or_generate_sample_str(s, rand_func=generate_random_sample_str):
    """If input string s is empty, return a random sample string.
    If input string s does not follow sample string pattern, raise a ValueError.
    Otherwise, return s."""
    if not s:
        return rand_func()
    if not match_sample_pattern(s):
        raise ValueError("Sample {s} must only contain letters and numbers)".format(s=s))
    else:
        return s
