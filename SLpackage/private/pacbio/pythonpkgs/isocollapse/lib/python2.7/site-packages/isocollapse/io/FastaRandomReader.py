# Copied from pbtranscript.io/FastaRandomReader
"""
Define FastaRandomReader which accesses reads in FASTA
or ContigSet files randomly.

Note that a ContigSet can contain multiple FASTA files,
but can only contain FASTA files and filters in the
ContigSet will not be respected.
"""
import os.path as op
import logging

from pbcore.io.FastaIO import FastaRecord
from pbcore.io import ContigSet


class FastaRandomReader(object):
    """
        A reader class to access sequences in a FASTA or ContigSet XML
        file randomely.

        Note that this class can take ContigSet file as input, however
        filters are not respected.

        This is meant to substitute for the Bio.SeqIO.to_dict method since some fasta files
        are too big to fit entirely to memory.

        The only requirement is that every id line begins with the symbol >.

        Example:
            r = FastaRandomReader('output/test.fna')
            r['6C_49273_NC_008578/2259031-2259297'] ==> this shows a FastaRecord

            r = FastaRandomReader('test.contigset.xml')
            r['m/zmw/s_e'] ==> this shows a FastaRecord
    """

    def __init__(self, fasta_filename, seqid_extraction=lambda x: x):
        self.fasta_filenames = self.get_fasta_filenames(fasta_filename)
        self.fhandlers = self._open_files()
        self.seqid_extraction = seqid_extraction
        self.d = {}
        self._init_index()

    def get_fasta_filenames(self, fasta_filenames):
        """Return all FASTA file names as a list."""
        fasta_filenames = [fasta_filenames] if isinstance(fasta_filenames, str) else fasta_filenames
        ret = []
        for fn in fasta_filenames:
            ext = op.splitext(fn)[1].upper()
            if ext in [".XML"]:
                try:
                    fns = ContigSet(fn).toExternalFiles()
                    ret.extend(fns)
                except IOError:
                    raise IOError("Could not open %s as ContigSet." % fn)
            else:
                ret.append(fn)
        for fn in ret:
            if op.splitext(fn)[1].upper() not in [".FA", ".FASTA"]:
                raise IOError("%s input must be FASTA or ContigSet."
                              % self.__class__.__name__)
        return ret

    def _open_files(self):
        return [open(fn) for fn in self.fasta_filenames]

    def _init_index(self):
        """Indexing reads in fasta_filenames"""
        for index, f in enumerate(self.fhandlers):
            while 1:
                line = f.readline()
                if len(line) == 0:
                    break
                if line.startswith('>'):
                    sid = line.strip()[1:].split(None, 1)[0]
                    # the header MUST be just 1 line
                    # if id in self.d:
                    #    print "duplicate id {0}!!".format(id)
                    sid = self.seqid_extraction(sid)
                    self.d[sid] = (index, f.tell())

    def __getitem__(self, k):
        if k not in self.d:
            errMsg = "key {k} not in {f}!".format(k=k, f=",".join(self.fasta_filenames))
            logging.error(self.d.keys())
            raise ValueError(errMsg)
        return self._get_record(k)

    def _get_record(self, k):
        index, tell = self.d[k]
        f = self.fhandlers[index]
        f.seek(tell)
        content = ''
        for line in f:
            if line.startswith('>'):
                break
            content += line.strip()
        return FastaRecord(header=k, sequence=content)

    def __len__(self):
        return len(self.d)

    def __delitem__(self, key):
        errMsg = "%s.__delitem__ not defined." % self.__class__.__name__
        raise NotImplementedError(errMsg)

    def __setitem__(self, key, value):
        errMsg = "%s.__setitem__ not defined." % self.__class__.__name__
        raise NotImplementedError(errMsg)

    def keys(self):
        """Return d.keys."""
        return self.d.keys()
