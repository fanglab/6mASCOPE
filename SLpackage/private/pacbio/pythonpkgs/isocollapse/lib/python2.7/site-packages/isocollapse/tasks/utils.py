"""
basic functions for making tool contract parser, running tool contract.
"""
from __future__ import absolute_import

import logging
import re
from collections import namedtuple

from pbcommand.cli import pbparser_runner
from pbcommand.utils import setup_log
from pbcommand.models import get_pbparser, FileTypes, ResourceTypes, SymbolTypes

from ..__init__ import get_tool_id, get_driver_exe, get_version, get_tcp_option_name, MAGIC_TOOL_ID

log = logging.getLogger(__name__)


TCP_INPUT = namedtuple('TCP_INPUT', ['file_type', 'file_id', 'name', 'description'])
TCP_OUTPUT = namedtuple('TCP_OUTPUT', ['file_type', 'file_id', 'name', 'description', 'default_name'])


def all_items_have_attrs(items, attrs):
    """Return True if all items has all attributes, otherwise, False"""
    for item in items:
        for attr in attrs:
            if not hasattr(item, attr):
                return False
    return True


class BaseConstants(object):
    """Class defining all constants needed for a tool contract.
    Concrete class MUST redefine: TOOL_NAME, DESCRIPTION, INPUT_FILES, OUTPUT_FILES
    Optionally redefine: NPROC, PARAMS.
    """
    TOOL_NAME = "unknown"
    DESCRIPTION = "unknown"
    INPUT_FILES = []
    OUTPUT_FILES = []
    NPROC = SymbolTypes.MAX_NPROC
    PARAMS = []
    VERSION = get_version()

    @classmethod
    def TOOL_ID(cls):
        """{MAGIC_TOOL_ID}.{tool_name}"""
        return get_tool_id(cls.TOOL_NAME)

    @classmethod
    def DRIVER_EXE(cls):
        """python -m {MAGIC_TOOL_ID}.{tool_name}"""
        return get_driver_exe(cls.TOOL_NAME)

    @classmethod
    def sanity_check(cls):
        """Sanity check class"""
        assert str(cls)
        pattern = re.compile(r"^([a-z])([a-z0-9_])+$")
        if pattern.match(cls.TOOL_NAME) is None:
            raise ValueError("TOOL_NAME %r must match pattern %r" % (cls.TOOL_NAME, pattern))
        if not cls.TOOL_ID().startswith(MAGIC_TOOL_ID):
            raise ValueError("TOOL_ID %r must starts with " % MAGIC_TOOL_ID)
        if not cls.DRIVER_EXE().startswith("python -m {}".format(MAGIC_TOOL_ID)):
            raise ValueError("DIRVER_EXE %r must starts with python -m %r" % (cls.DRIVER_EXE(), MAGIC_TOOL_ID))
        assert all([isinstance(x, TCP_INPUT) for x in cls.INPUT_FILES])
        assert all([isinstance(x, TCP_OUTPUT) for x in cls.OUTPUT_FILES])
        assert all_items_have_attrs(cls.PARAMS, ['type', 'name', 'desc', 'val'])

    @classmethod
    def __str__(cls):
        attrs = ['TOOL_NAME', 'VERSION', 'DESCRIPTION',
                 'NPROC', 'PARAMS', 'INPUT_FILES', 'OUTPUT_FILES']
        msg = ['TOOL_ID: %r' % cls.TOOL_ID(), 'DRIVER_EXE: %r' % cls.DRIVER_EXE()]
        msg = msg.extend(['%s: %r' % (attr, getattr(cls, attr)) for attr in attrs])
        return '\n'.join(msg)


def get_contract_parser_from_const(const):
    """Get tool contract parser from const.
    const --- Constants
    default_level --- debug leve, e.g., 'INFO', 'DEBUG',
    """
    p = get_pbparser(tool_id=const.TOOL_ID(),
                     version=get_version(),
                     name=const.TOOL_ID(),
                     description=const.DESCRIPTION,
                     driver_exe=const.DRIVER_EXE(),
                     nproc=const.NPROC,
                     resource_types=(ResourceTypes.TMP_DIR,),
                     default_level='DEBUG')
    add_io_args_const_to_parser(p, const=const)
    return p


def add_io_args_const_to_parser(p, const):
    """Add io and options defined in const to tcp"""
    for f in const.INPUT_FILES:
        p.add_input_file_type(f.file_type, f.file_id, f.name, f.description)

    for f in const.OUTPUT_FILES:
        p.tool_contract_parser.add_output_file_type(f.file_type, f.file_id, f.name, f.description, f.default_name)

    p.arg_parser.parser.add_argument('output_prefix', help='output prefix')
    add_tcp_parser_options(p, params=const.PARAMS)
    return p


def __get_tcp_parser_add_arg_func(p, param):
    """
    return tcp add arg function based on param type
    p --- tcp parser
    param --- Constant.PARAM
    """
    if param.type is float:
        return p.add_float
    if param.type is int:
        return p.add_int
    if param.type is bool:
        return p.add_boolean
    if param.type is str:
        return p.add_str
    raise ValueError("Could not get add_type function for type %s" % param.type)


def __add_tcp_parser_option(p, param):
    """Add a param as an option to tcp parser
    p --- tcp parser
    param --- Constant.PARAM
    """
    option_id = get_tcp_option_name(param.name)
    log.info('option_id is %s', option_id)
    p = __get_tcp_parser_add_arg_func(p, param)(option_id=option_id, option_str=param.name,
                                                name=param.display_name, default=param.val, description=param.desc)
    return p


def add_tcp_parser_options(p, params):
    """Add configurable params as options to tcp parser
    e.g., params = ['min_aln_coverage'] --> tcp.task.options['{MAGIC}.task_options.min_aln_coverage']
    """
    for param in params:
        __add_tcp_parser_option(p, param)
    return p
