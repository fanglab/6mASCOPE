# -*- coding: utf-8 -*-

from pbcommand.testkit.xunit import convert_suite_and_result_to_xunit
"""
Report-driven, dynamically generated test cases
"""

import operator as OP
import unittest
import logging
import re
import sys
# FIXME see https://stackoverflow.com/a/21190382
reload(sys)
sys.setdefaultencoding('utf8')


log = logging.getLogger(__name__)


def _get_attr_id_and_op(key):
    fields = key.split("__")
    if len(fields) > 2:
        raise ValueError("Don't know how to parse key '{k}'".format(k=key))
    default_op = "ne" if fields[0].endswith("!") else "eq"
    op_id = default_op if len(fields) < 2 else fields[1]
    if not op_id in {"lt", "gt", "le", "ge", "eq", "ne"}:
        raise KeyError(
            "Don't know how to interpret operator '{o}'".format(o=op_id))
    return fields[0].replace("!", ""), op_id


class ReportTestBase(unittest.TestCase):
    """
    Base class for evaluating report attributes against a dictionary of
    expected values.
    """

    JOB_ID = None
    REPORT_ID = None
    REPORT_SRC = None
    TEST_VALUES = {}
    REPORT_ATTR = None
    REPORT_TABLES = None
    OTHER_TESTS = {} # interface for bolting on other methods e.g. pbvalidate

    # dynamically define test cases at the time of class definition.  in
    # the vanilla unittest framework this could be deferred until later, but
    # for our pbsmrtpipe tests the new methods need to be visible on import
    class __metaclass__(type):

        def __new__(cls, classname, bases, classdict):
            test_id = classdict["REPORT_ID"]
            for key, value in classdict["TEST_VALUES"].iteritems():
                method_name = "test_{j}_{k}".format(j=classdict["JOB_ID"],
                                                    k=re.sub("__", "_", key))
                if isinstance(value, dict):
                    for key2, value2 in value.iteritems():
                        col_id, op_id = _get_attr_id_and_op(key2)
                        method_name2 = "_".join([method_name, col_id])
                        test_f = ReportTestBase.make_table_column_test(
                            key, key2, value2)
                        test_f.__doc__ = """{r}.{t}.{c} .{o}. {v}""".format(
                            r=test_id, t=key, c=col_id, o=op_id, v=value2)
                        test_f.__name__ = str(method_name2)
                        classdict[method_name2] = test_f
                else:
                    test_f = ReportTestBase.make_attr_test(key, value)
                    attr_id, op_id = _get_attr_id_and_op(key)
                    test_f.__doc__ = """{r}.{a} .{o}. {v}""".format(
                        r=test_id, a=attr_id, o=op_id, v=value)
                    test_f.__name__ = method_name
                    classdict[method_name] = test_f
            for method_name, fx in classdict["OTHER_TESTS"].iteritems():
                test_f = ReportTestBase.make_other_test(fx)
                test_f.__doc__ = "External method {f}".format(f=method_name)
                test_f.__name__ = method_name
                classdict[method_name] = test_f
            return type.__new__(cls, classname, bases, classdict)

    @staticmethod
    def make_attr_test(key, value):
        def test(self):
            return self._compare_attribute(key, value)
        return test

    @staticmethod
    def make_table_column_test(table_id, key, values):
        assert isinstance(values, list)

        def test(self):
            return self._compare_table_column(table_id, key, values)
        return test

    @staticmethod
    def make_other_test(fx):
        assert hasattr(fx, "__call__")

        def test(self):
            return fx(self)
        return test

    def _compare_attribute(self, key, value):
        attr_id, op_id = _get_attr_id_and_op(key)
        if not attr_id in self.REPORT_ATTR:
            raise KeyError(
                "Can't find report attribute with ID '{i}'".format(i=attr_id))
        actual = self.REPORT_ATTR[attr_id]

        def _to_str(o, n, k, a, v):
            return "{n} ({k}): {a} .{o}. {v}".format(k=k, o=o, n=n, a=a, v=v)
        operator = getattr(OP, op_id)
        op_test_success = operator(actual.value, value)
        name = actual.name if actual.name is not None else attr_id
        msg = _to_str(op_id, attr_id, name.encode('utf-8'), actual.value, value)
        self.assertTrue(op_test_success, msg +
                        "\n(source: {s})".format(s=self.REPORT_SRC))
        log.info("Passed: {m}".format(m=msg))

    def _compare_table_column(self, table_id, key, values):
        if not table_id in self.REPORT_TABLES:
            raise KeyError("No report table with ID '{i}'".format(i=table_id))
        table = self.REPORT_TABLES[table_id]
        col_id, op_id = _get_attr_id_and_op(key)
        column = table.get_column_by_id(col_id)
        if column is None:
            raise KeyError("No column '{c}' in table '{t}'".format(
                           c=col_id, t=table_id))
        operator = getattr(OP, op_id)
        test_states = []
        for v_expected, v_actual in zip(values, column.values):
            test_states.append(operator(v_actual, v_expected))

        def _to_str(o, t, c, a, v):
            return "{t}.{c}: {a} .{o}. {v}".format(t=t, c=c, o=o, a=a, v=v)
        msg = _to_str(op_id, table_id, col_id, column.values, values)
        self.assertTrue(all(test_states), msg +
                        "\n(source: {s})".format(s=self.REPORT_SRC))
        log.info("Passed: {m}".format(m=msg))


def make_report_tests(job_id, report, test_values, report_src,
                      test_functions_d={}):
    class K(ReportTestBase):
        JOB_ID = job_id
        REPORT_ID = report.id
        REPORT_SRC = report_src
        REPORT_ATTR = {a.id: a for a in report.attributes}
        REPORT_TABLES = {t.id: t for t in report.tables}
        TEST_VALUES = test_values
        OTHER_TESTS = test_functions_d
    K.__name__ = "test_{r}".format(r=report.id)
    return K


def make_test_suite(test_classes):
    test_cases = []
    for tc in test_classes:
        test_cases.append(unittest.TestLoader().loadTestsFromTestCase(tc))
    return test_cases, unittest.TestSuite(test_cases)


def run_tests(test_classes, output_xml=None, stream=sys.stderr):
    test_cases, test_suite = make_test_suite(test_classes)
    runner = unittest.TextTestRunner(verbosity=0, stream=stream)
    result = runner.run(test_suite)
    if output_xml is not None:
        xml = convert_suite_and_result_to_xunit(test_cases, result)
        log.debug("Writing Xunit XML output to {f}".format(f=output_xml))
        with open(output_xml, 'w+') as f:
            f.write(unicode(xml))
    return result
