from wdl_parser import version_1_0 as parser  # pylint: disable=import-error

# PUBLIC FUNCTIONS


def get_missing_inputs(wdl_sin, inputs):
    """Return a list of required inputs that are not in 'inputs'.
    inputs: list of ['workflow.input_name', ...]
    """
    workflow = parse_workflow(wdl_sin)
    possible_inputs = workflow.inputs
    required = ['{}.{}'.format(workflow.name, i.name)
                for i in possible_inputs if i.required]
    missing = list(set(required) - set(inputs))
    missing.sort()
    return missing


def get_file_inputs(wdl_sin, inputs):
    """Return all keys in 'inputs' that are 'File' type.
    inputs: list of ['workflow.input_name', ...]
    """
    workflow = parse_workflow(wdl_sin)
    possible_inputs = workflow.inputs
    file_inputs = ['{}.{}'.format(workflow.name, i.name)
                   for i in possible_inputs if isinstance(i, InputFile)]
    file_inputs.sort()
    return [i for i in file_inputs if i in inputs]


# IMPLEMENTATION

def parse_workflow(sin):
    """Return a Workflow object.
    """
    tree = parser.parse(sin.read())
    ast = tree.ast()
    #print ast.dumps(indent=2, separators=(',', ': '), sort_keys=True)
    return get_workflow(ast)


class Input(object):
    type_name = None
    option_type_id = None
    value_type = str

    def find_default(self, ast):
        try:
            expr = ast.attributes["expression"]
            default_value = expr.source_string
        except AttributeError as e:
            default_value = None
        return default_value

    @property
    def name(self):
        return self._name

    @property
    def required(self):
        return self._required

    @property
    def value(self):
        return self.value_type(self._value) if self._value is not None else None

    def __repr__(self):
        return '{}({}{})'.format(
            type(self).__name__,
            self.name,
            '' if self.required else '?')

    def __init__(self, ast, required, value):
        # Technically, the ast is an 'InputDeclaration'.
        self._name = ast.attributes['name'].source_string
        self._required = required
        self._value = self.find_default(ast) if value is None else value


class InputFile(Input):
    type_name = "File"

    def __init__(self, ast, required, value=None):
        super(InputFile, self).__init__(ast, required, value)


class InputNumber(Input):
    # we have to override this because the handling of negative numbers is
    # very messy
    def find_default(self, ast):
        default_value = None
        try:
            expr = ast.attributes["expression"]
            if hasattr(expr, "source_string"):
                default_value = expr.source_string
            elif getattr(expr, "name", None) == "UnaryNegation":
                expr2 = expr.attributes["expression"]
                default_value = -1 * self.value_type(expr2.source_string)
        except AttributeError as e:
            pass
        return default_value


class InputInt(InputNumber):
    type_name = "Int"
    option_type_id = "integer"
    value_type = int

    def __init__(self, ast, required, value=None):
        super(InputInt, self).__init__(ast, required, value)


class InputString(Input):
    type_name = "String"
    option_type_id = "string"
    value_type = str

    def find_default(self, ast):
        try:
            expr = ast.attributes["expression"]
            default_value = ""
            if "pieces" in expr.attributes:
                pieces = expr.attributes["pieces"]
                if len(pieces) > 0:
                    default_value = pieces[0].source_string
        except AttributeError as e:
            default_value = None
        return default_value

    def __init__(self, ast, required, value=None):
        super(InputString, self).__init__(ast, required, value)


class InputFloat(InputNumber):
    type_name = "Float"
    option_type_id = "float"
    value_type = float

    def __init__(self, ast, required, value=None):
        super(InputFloat, self).__init__(ast, required, value)


class InputBoolean(Input):
    type_name = "Boolean"
    option_type_id = "boolean"
    value_type = bool

    def __init__(self, ast, required, value=None):
        super(InputBoolean, self).__init__(ast, required, value)

    @property
    def value(self):
        if self._value is not None and self._value.lower() == "false":
            return False
        else:
            return bool(self._value)


ALLOWED_TYPES = [InputFile, InputInt, InputString, InputFloat, InputBoolean]


def build_input(ast):
    if getattr(ast.attr('type'), 'name', '') == 'OptionalType':
        # We consider an input as optional if it has '?', and thus this node.
        type_name = ast.attr('type').attr('innerType').source_string
        required = False
    else:
        type_name = ast.attr('type').source_string
        # Technically, a default value implies optionality even without '?'.
        # but our wdl_parser does not add the OptionalType AST node in that case.
        # https://github.com/openwdl/wdl/blob/master/versions/1.0/SPEC.md#declared-inputs-defaults-and-overrides
        expression_ast = ast.attr('expression')
        if expression_ast:
            required = False
        else:
            required = True
    type_classes = {t.type_name: t for t in ALLOWED_TYPES}
    cls = type_classes.get(type_name, None)
    if cls is None:
        msg = 'We do not handle Inputs of type "{}".'.format(type_name)
        raise SyntaxError(msg)
    return cls(ast, required)


class Workflow(object):
    @property
    def name(self):
        return self._name

    @property
    def inputs(self):
        return self._inputs

    def __repr__(self):
        return 'Workflow({}, {!r})'.format(self.name, self.inputs)

    def __init__(self, ast):
        self._name = ast.attributes['name'].source_string
        inputs_asts = [elem for elem in ast.attr(
            'body') if elem.name == 'Inputs']
        assert len(inputs_asts) == 1, repr(inputs_asts)
        self._inputs = [build_input(elem)
                        for elem in inputs_asts[0].attr('inputs')]

    def valid_input_keys(self):
        return {i.name for i in self._inputs}


def get_workflow(ast):
    body = ast.attr('body')
    workflows = [Workflow(elem) for elem in body if elem.name == 'Workflow']
    if len(workflows) > 1:
        names = [w.name for w in workflows]
        raise Exception('More than 1 workflow found in ast: {}'.format(names))
    if len(workflows) == 0:
        raise Exception(
            'No workflow found in ast:\n{}'.format(ast.dumps(indent=2, separators=(',', ': '), sort_keys=True)))
    return workflows[0]


class Task(object):
    @property
    def name(self):
        return self._name

    def __repr__(self):
        return 'Task({})'.format(self.name)

    def __init__(self, ast):
        self._name = ast.attributes['name'].source_string


def yield_tasks(ast):
    body = ast.attr('body')
    for elem in body:
        if elem.name == 'Task':
            #print 'Task name source_string:', elem.attributes['name'].source_string
            yield Task(elem)
