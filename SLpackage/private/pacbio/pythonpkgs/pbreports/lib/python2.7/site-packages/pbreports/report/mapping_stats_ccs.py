
"""
Generates a report of statistics for CCS reads mapped to a reference genome
with Blasr/pbalign.
"""

from collections import namedtuple
import logging
import os.path as op
import sys

import numpy as np

from pbcommand.models import get_pbparser, FileTypes
from pbcommand.models.report import Report, Attribute, Column, Table, PlotGroup, Plot
from pbcommand.cli import pbparser_runner
from pbcommand.utils import setup_log, pool_map
from pbcore.io import ConsensusAlignmentSet, IndexedBamReader

from pbreports.report import mapping_stats
from pbreports.io.mapped import (collect_ccs_pbi_alignment_metrics,
                                 combine_chunked_alignment_metrics)
from pbreports.plot.helper import to_plotgroup
from pbreports.plot.tools import (plot_mapped_concordance_vs_read_length_hist2d,
                                  plot_accuracy_vs_concordance)
from pbreports.io.specs import load_spec
from pbreports.statistics import to_readlength_accuracy_histogram2d

__version__ = "1.3"
log = logging.getLogger(__name__)


class Constants(mapping_stats.Constants):
    TOOL_ID = "pbreports.tasks.mapping_stats_ccs"
    DRIVER_EXE = "python -m pbreports.report.mapping_stats_ccs --resolved-tool-contract"
    MAPPED_FILE_TYPE = FileTypes.DS_ALIGN_CCS

    R_ID = "mapping_stats_ccs"
    SPEC = load_spec(R_ID)

    A_READ_CONCORDANCE = "mapped_read_concordance_mean"
    C_NBASES = "mapped_bases"
    C_READLENGTH = "mapped_read_length_mean"
    C_READLENGTH_N50 = "mapped_read_length_n50"
    C_READ_CONCORDANCE = "mapped_read_concordance_mean"

    PG_CONCORDANCE_HIST = "ccs_read_concordance_group"
    P_CONCORDANCE_HIST = "concordance_plot"
    PNG_CONCORDANCE_HIST = "mapped_read_concordance_histogram.png"
    PG_READLENGTH = "ccs_readlength_group"
    PG_QV_CALIBRATION = "qv_calibration_group"
    P_QV_CALIBRATION = "qv_calibration_plot"
    PNG_QV_CALIBRATION = "mapped_qv_calibration.png"


MStats = namedtuple("MStats", ["movie_stats", "qlen", "identity", "readQual"])


def _to_bam_stats(bam_file):
    with IndexedBamReader(bam_file) as bam:
        movie_names = {rg.ID: rg.MovieName for rg in bam.readGroupTable}
        stats = collect_ccs_pbi_alignment_metrics(bam.pbi, movie_names)
        return MStats(stats,
                      bam.pbi.aEnd - bam.pbi.aStart,
                      bam.pbi.identity if len(bam) > 0 else np.array([]),
                      bam.pbi.readQual)


def get_all_bam_stats(bam_files, nproc):
    """
    Collect read statistics objects in parallel from the list of indexed BAM
    files.
    """
    log.info("Collecting metrics from %d bam.pbi files", len(bam_files))
    result = pool_map(_to_bam_stats, bam_files, nproc)
    stats = [r.movie_stats for r in result]
    combined, by_movie = combine_chunked_alignment_metrics(stats)
    return MStats((combined, by_movie),
                  np.concatenate([r.qlen for r in result]),
                  np.concatenate([r.identity for r in result]),
                  np.concatenate([r.readQual for r in result]))


def _to_attributes(aln_info):
    attr = []
    for id_, value in [
            (Constants.A_READ_CONCORDANCE, aln_info.info.mean_identity),
            (Constants.A_NALIGNMENTS, aln_info.info.n_alignments),
            (Constants.A_NREADS, aln_info.subreads.size),  # XXX yes, "subreads"
            (Constants.A_NBASES, aln_info.reads.nbases),
            (Constants.A_READLENGTH, aln_info.reads.mean),
            (Constants.A_READLENGTH_N50, aln_info.reads.n50),
            (Constants.A_READLENGTH_Q95, aln_info.reads.q95),
            (Constants.A_READLENGTH_MAX, aln_info.reads.max)]:
        log.info("%s = %g", id_, value)
        attr.append(Attribute(id_, value=value))
    return attr


def _to_table_row(aln_info):
    name = aln_info.movie_name if aln_info.movie_name else "All Movies"
    return [
        (Constants.C_MOVIE, name),
        (Constants.C_READS, aln_info.reads.size),
        (Constants.C_READLENGTH, aln_info.reads.mean),
        (Constants.C_READLENGTH_N50, aln_info.reads.n50),
        (Constants.C_NBASES, aln_info.reads.nbases),
        (Constants.C_READ_CONCORDANCE, aln_info.info.mean_identity)
    ]


def _to_tables(combined, by_movie):
    return [mapping_stats.to_read_metrics_table(_to_table_row, combined, by_movie)]


def _to_length_vs_concordance_plot(read_lengths, concordance, output_dir):
    png_file_name = op.join(output_dir, Constants.PNG_RAINBOW)
    plot_spec = Constants.SPEC.get_plot_spec(
        Constants.PG_RAINBOW, Constants.P_RAINBOW)
    png, thumb = plot_mapped_concordance_vs_read_length_hist2d(
        to_readlength_accuracy_histogram2d(read_lengths, concordance),
        png_file_name,
        x_label=plot_spec.xlabel)
    return to_plotgroup(Constants.PG_RAINBOW, Constants.P_RAINBOW, png, thumb)


def _to_mapped_qv_calibration_plot(readQual, concordance, output_dir):
    pg_id, plot_id = Constants.PG_QV_CALIBRATION, Constants.P_QV_CALIBRATION
    png_file_name = op.join(output_dir, Constants.PNG_QV_CALIBRATION)
    plot_spec = Constants.SPEC.get_plot_spec(pg_id, plot_id)
    png, thumb = plot_accuracy_vs_concordance(
        readQual,
        concordance,
        png_file_name,
        x_label=plot_spec.xlabel,
        y_label=plot_spec.ylabel)
    return to_plotgroup(pg_id, plot_id, png, thumb)


def _to_plotgroups(mstats, output_dir):
    metrics, _ = mstats.movie_stats
    return [
        mapping_stats.to_read_length_histogram(Constants, metrics, output_dir),
        mapping_stats.to_concordance_histogram(Constants, metrics, output_dir),
        _to_length_vs_concordance_plot(
            mstats.qlen, mstats.identity, output_dir),
        _to_mapped_qv_calibration_plot(
            mstats.readQual, mstats.identity, output_dir)
    ]


def make_report(bam_files, output_dir, nproc=1, dataset_uuids=()):
    """
    Collect data from BAM indices and populate Report object.
    """
    mstats = get_all_bam_stats(bam_files, nproc)
    combined, by_movie = mstats.movie_stats
    plotgroups = []
    if combined.info.n_reads > 0:
        plotgroups = _to_plotgroups(mstats, output_dir)
    return Report(
        Constants.R_ID,
        attributes=_to_attributes(combined),
        tables=_to_tables(combined, by_movie),
        plotgroups=plotgroups,
        dataset_uuids=dataset_uuids)


def to_report(alignment_file, report_json, nproc=1):
    """
    Main entry function including I/O.
    """
    output_dir = op.dirname(report_json)
    bam_files = []
    log.info("Opening %s as a ConsensusAlignmentSet", alignment_file)
    with ConsensusAlignmentSet(alignment_file, strict=True, skipCounts=True) as ds:
        for bam_resource in ds.externalResources:
            if bam_resource.pbi is None:
                raise ValueError(
                    "This program requires PacBio-indexed (.pbi) BAM files")
            bam_files.append(bam_resource.bam)
        rpt = Constants.SPEC.apply_view(make_report(
            bam_files, output_dir, nproc, [ds.uuid]))
        rpt.write_json(report_json)
        log.info("Wrote report to %s", report_json)
    return 0


def _args_runner(args):  # pragma: no cover
    return to_report(args.alignment_file, args.report_json, nproc=args.nproc)


def _rtc_runner(rtc):  # pragma: no cover
    return to_report(rtc.task.input_files[0], rtc.task.output_files[0],
                     nproc=rtc.task.nproc)


def _get_parser():  # pragma: no cover
    return mapping_stats.get_parser(Constants)


def main(argv=sys.argv):  # pragma: no cover
    return pbparser_runner(argv[1:],
                           _get_parser(),
                           _args_runner,
                           _rtc_runner,
                           log,
                           setup_log)


if __name__ == '__main__':
    sys.exit(main(sys.argv))
