# -*- coding: utf-8 -*-

"""
Functions to generate various specific plots.
"""

from __future__ import division
from collections import defaultdict
import functools
import logging
import math

import numpy as np

from pbreports.statistics import compute_n50_and_n95, Constants, get_read_length_histogram_bin_width, rebin_histogram
from pbreports.plot.helper import *


log = logging.getLogger(__name__)


def _save_and_close(fig, png_file_name, dpi):
    png, thumb = save_figure_with_thumbnail(fig, png_file_name, dpi=int(dpi))
    plt.close(fig)
    return (png, thumb)


# the formatting varies depending on the report in question but we should
# try to keep all hacks specific to PB read lengths in one place
def _plot_read_lengths(read_type,
                       read_lengths,
                       png_file_name,
                       dpi=DEFAULT_DPI,
                       title=None,
                       bins=40,
                       color=get_green(0),
                       edgecolor=get_green(0),
                       rwidth=0.9):
    """
    Plot a histogram of read lengths (of any type, defaulting to "Read").
    """
    fig, axes = get_fig_axes_lpr()
    axes.hist(read_lengths,
              bins=bins,
              color=color,
              edgecolor=edgecolor,
              rwidth=rwidth)
    axes.set_xlabel(u"{t} Length (bp)".format(t=read_type))
    axes.set_ylabel(u"Number of {t}s".format(t=read_type))
    if title is not None:
        axes.set_title(title, fontsize=20)
    fig.canvas.draw()
    from matplotlib.ticker import MaxNLocator
    axes.get_yaxis().set_major_locator(MaxNLocator(integer=True))
    set_axis_tick_label_comma_format(axes.get_xaxis())
    set_axis_tick_label_comma_format(axes.get_yaxis())
    return _save_and_close(fig, png_file_name, dpi)


plot_read_lengths = functools.partial(_plot_read_lengths, "Read")
plot_ccs_read_lengths = functools.partial(_plot_read_lengths, u'≥Q20 Read')
plot_subread_lengths = functools.partial(_plot_read_lengths, "Subread")


def _plot_histogram_with_cdf(xdata, cdf_xy_data, bins, color, edgecolor, rwidth, axis_labels):
    fig, axes = get_fig_axes_lpr()
    axes.hist(xdata,
              bins=bins,
              color=color,
              edgecolor=edgecolor,
              rwidth=rwidth,
              linewidth=0.5)
    axes.set_xlabel(axis_labels[0])
    axes.set_ylabel(axis_labels[1])
    cdf_x_data, cdf_y_data = cdf_xy_data
    rax = axes.twinx()
    rax.plot(cdf_x_data, cdf_y_data, 'k')
    rax.set_ylabel(axis_labels[2])
    rax.set_ylim(0, np.max(cdf_y_data))
    fig.tight_layout()
    return fig


def plot_read_lengths_with_cdf(
        read_lengths,
        png_file_name,
        axis_labels=("Read Length (bp)", "Reads", "Reads > Read Length"),
        color=get_blue(3),
        edgecolor=get_blue(2),
        bins=50,
        rwidth=0.9,
        dpi=DEFAULT_DPI):
    """
    Plot a histogram of read lengths along with CDF curve.
    """
    bincounts = np.bincount(read_lengths)
    bin_lengths = np.arange(len(bincounts))
    csum = np.cumsum(bincounts)
    sum_max = csum[-1]
    sdf = np.full(len(csum), sum_max, dtype=int) - csum
    fig = _plot_histogram_with_cdf(read_lengths, (bin_lengths, sdf), bins, color, edgecolor, rwidth, axis_labels)
    return _save_and_close(fig, png_file_name, dpi)


def plot_read_lengths_with_bases_cdf(
        read_lengths,
        png_file_name,
        axis_labels=("Read Length (bp)", "Reads"),
        cdf_axis_label="Mb > Read Length",
        cdf_scale=1000000,
        color=get_blue(3),
        edgecolor=get_blue(2),
        bins=50,
        rwidth=0.9,
        dpi=DEFAULT_DPI):
    """
    Plot a histogram of read lengths along with CDF curve of the number of
    megabases (or other scale).
    """
    bincounts = np.bincount(read_lengths)
    bin_lengths = np.arange(len(bincounts))
    csum = np.cumsum(bincounts * bin_lengths) / cdf_scale
    sum_max = csum[-1]
    sdf = np.full(len(csum), sum_max, dtype=int) - csum
    fig = _plot_histogram_with_cdf(read_lengths, (bin_lengths, sdf), bins, color, edgecolor, rwidth, list(axis_labels) + [cdf_axis_label])
    return _save_and_close(fig, png_file_name, dpi)


def plot_read_scores(
        read_scores,
        png_file_name,
        axis_labels=("Read Quality", "Reads"),
        color=get_green(3),
        edgecolor=get_green(3),
        rwidth=0.9,
        dpi=DEFAULT_DPI,
        cutoff_line=None):
    """
    Plot a histogram of Phred scores, with separate coloring for bins below
    an optional cutoff.
    """
    from matplotlib.ticker import MaxNLocator
    fig, axes = get_fig_axes_lpr()
    min_score = int(math.floor(np.min(read_scores)))
    max_score = int(math.ceil(np.max(read_scores)))
    bins = []
    k = min_score
    while k <= max_score:
        # this is a hack to force the bars to appear on the right side of the
        # integral value, e.g. Q60 will appear on the left hand of the final
        # bar in the plot
        bins.append(k - 0.000001)
        k += 1
    bins.append(max_score + 1)
    if cutoff_line is not None and np.min(read_scores) < cutoff_line:
        scores_above = read_scores[read_scores >= cutoff_line]
        scores_below = read_scores[read_scores < cutoff_line]
        axes.hist([scores_above, scores_below],
                  bins=bins,
                  stacked=True,
                  rwidth=rwidth,
                  color=[color, "#a0a0a0"])
        #axes.axvline(cutoff_line, color='r')
    else:
        axes.hist(read_scores,
                  bins=bins,
                  color=color,
                  edgecolor=edgecolor,
                  rwidth=rwidth)
    axes.set_xlabel(axis_labels[0])
    axes.set_ylabel(axis_labels[1])
    axes.get_yaxis().set_major_locator(MaxNLocator(integer=True))
    set_axis_tick_label_comma_format(axes.get_yaxis())
    fig.canvas.draw()  # https://stackoverflow.com/a/41124884
    axes.set_xticklabels(["Q" + x.get_text() for x in axes.get_xticklabels()])
    return _save_and_close(fig, png_file_name, dpi)


def _plot_read_length_distribution_with_score_cutoff(
        read_lengths,
        read_scores,
        png_file_name,
        min_score,
        bar_labels,
        axis_labels=("Read Length (bp)", "Reads"),
        bins=50,
        rwidth=0.9,
        dpi=DEFAULT_DPI):
    """
    Plot a stacked histogram of read lengths split by a score/quality cutoff.
    """
    from matplotlib.ticker import MaxNLocator
    assert len(read_lengths) == len(read_scores)
    fig, axes = get_fig_axes_lpr()
    hi_q_sel = read_scores >= min_score
    hi_q_lengths = read_lengths[hi_q_sel]
    low_q_lengths = read_lengths[np.invert(hi_q_sel)]
    if len(low_q_lengths) != 0:
        axes.hist([hi_q_lengths, low_q_lengths],
                  bins=bins,
                  stacked=True,
                  rwidth=rwidth,
                  color=[get_green(3), "#a0a0a0"],  # lq = grey
                  label=bar_labels)
        axes.legend()
    else:
        axes.hist(hi_q_lengths,
                  bins=bins,
                  rwidth=rwidth,
                  color=get_green(3))
    axes.set_xlabel(axis_labels[0])
    axes.set_ylabel(axis_labels[1])
    axes.get_yaxis().set_major_locator(MaxNLocator(integer=True))
    set_axis_tick_label_comma_format(axes.get_xaxis())
    set_axis_tick_label_comma_format(axes.get_yaxis())
    return _save_and_close(fig, png_file_name, dpi)


def plot_q20_read_length_distribution(
        read_lengths,
        read_scores,
        png_file_name,
        axis_labels=("Read Length (bp)", "Reads"),
        bins=50,
        rwidth=0.9,
        dpi=DEFAULT_DPI):
    return _plot_read_length_distribution_with_score_cutoff(
        read_lengths,
        read_scores,
        png_file_name,
        min_score=20,
        bar_labels=(u"≥Q20 reads", "<Q20"),
        axis_labels=axis_labels,
        bins=bins,
        rwidth=rwidth,
        dpi=dpi)


def plot_stats_xml_distribution(dist, xlabel, ylabel, png_file_name, dpi=DEFAULT_DPI):
    """
    Plot a distribution extracted from the SubreadSet sts.xml.
    """
    fig, axes = get_fig_axes_lpr()
    axes.bar(dist.labels, dist.bins,
             color=get_green(0),
             edgecolor=get_green(0),
             width=(dist.binWidth * 0.75))
    axes.set_xlabel(xlabel)
    axes.set_ylabel(ylabel)
    return _save_and_close(fig, png_file_name, dpi)


def plot_hq_start_histogram(hq_starts,
                            png_file_name,
                            axis_labels=("HQ Region Start Position",
                                         "Number of Reads"),
                            bins=50,
                            rwidth=0.75,
                            dpi=DEFAULT_DPI):
    fig, axes = get_fig_axes_lpr()
    logbins = np.logspace(0, np.log10(hq_starts.max()), bins)
    axes.hist(hq_starts,
              bins=logbins,
              rwidth=rwidth,
              color=get_green(0),
              edgecolor=get_green(0))
    axes.set_xscale("log")
    axes.set_xlabel(axis_labels[0])
    axes.set_ylabel(axis_labels[1])
    from matplotlib.ticker import MaxNLocator
    axes.get_yaxis().set_major_locator(MaxNLocator(integer=True))
    set_axis_tick_label_comma_format(axes.get_xaxis())
    set_axis_tick_label_comma_format(axes.get_yaxis())
    return _save_and_close(fig, png_file_name, dpi)


def plot_insert_length_vs_read_length(read_lengths,
                                      insert_lengths,
                                      png_file_name,
                                      dpi=DEFAULT_DPI,
                                      log_scale=True,
                                      title=None):
    """
    Generate a hexbin plot of insert length versus HQ read length.
    """
    def _get_ticks(vmin, vmax):
        vmin, vmax = 10**vmin, 10**vmax
        ticks = []
        for n in [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000]:
            if vmin <= n <= vmax:
                ticks.append(n)
        return ticks
    import matplotlib.cm
    import matplotlib.colors
    import matplotlib.ticker
    import numpy as np
    CMAP = "rainbow"
    x = read_lengths
    y = insert_lengths
    assert len(x) == len(y)
    xlabel = "HQ Read Length"
    ylabel = "Insert Read Length"
    if log_scale:
        log.debug("Log-scaling")
        #xlabel += " (Log 10)"
        #ylabel += " (Log 10)"
        x = np.log10(x)
        y = np.log10(y)
    log.debug("Creating plot")
    bins = "log"  # this is the colormap scaling, not the x/y
    fig, axes = get_fig_axes(dims=(9, 12),
                             facecolor="#ffffff",
                             gridcolor="#a0a0a0")
    cmap = matplotlib.cm.get_cmap(CMAP, 16)
    cmap.set_under(color=(1.0, 1.0, 1.0, 0.0))  # pylint: disable=no-member
    min_xy = min(x.min(), y.min()) * 0.95
    max_xy = max(x.max(), y.max()) * 1.02
    hb = axes.hexbin(x, y, gridsize=(80, 80), vmin=0.01, cmap=cmap, bins=bins,
                     extent=(min_xy, max_xy, min_xy, max_xy))
    axes.set_xlabel(xlabel, fontsize=20)
    axes.set_ylabel(ylabel, fontsize=20)
    if title is not None:
        axes.set_title(title, fontsize=20)
    # integer axis labels
    xmin, xmax = axes.get_xlim()
    ymin, ymay = axes.get_ylim()
    xticks = _get_ticks(xmin, xmax)
    yticks = _get_ticks(ymin, ymay)
    axes.set_xticks([math.log10(n) for n in xticks])
    axes.set_yticks([math.log10(n) for n in yticks])
    axes.set_xticklabels(["{:,}".format(n) for n in xticks])
    axes.set_yticklabels(["{:,}".format(n) for n in yticks])
    for tick in axes.get_xticklabels():
        tick.set_rotation(45)
    # colorbar
    cb = fig.colorbar(hb, ax=axes)
    cmin, cmax = cb.get_clim()
    cb.set_label("Counts", fontsize=20)
    cb_ticks = [(-0.03125 + (0.0625 * i)) for i in range(1, 17)]
    cb.ax.get_yaxis().set_ticks(cb_ticks)
    cb_tick_labels = [str(int(np.round(10**(t * cmax)))) for t in cb_ticks]
    cb.ax.get_yaxis().set_ticklabels(cb_tick_labels)
    return _save_and_close(fig, png_file_name, dpi)


def plot_base_yield_histogram(read_lengths, png_file_name, dpi=DEFAULT_DPI,
                              bin_size=2000):
    """
    Plot the yield of bases in a collection as a function of the length of the
    containing read
    """
    from matplotlib.patches import Polygon
    from matplotlib.lines import Line2D
    assert bin_size % 2 == 0
    n50, n95 = compute_n50_and_n95(read_lengths)
    bins = []
    bin_max = 1 + (max(read_lengths) // bin_size)
    x = [0] + [(bin_size // 2) + (bin_size * i_bin)
               for i_bin in range(bin_max)]
    y = [0] + [0 for i_bin in range(bin_max)]
    for rlen in read_lengths:
        i_bin = 1 + (rlen // bin_size)
        y[i_bin] += rlen / bin_size  # FLOAT
    fig, axes = get_fig_axes(
        facecolor="#ffffff",
        gridcolor="#ffffff")
    axes.plot(x, y, color=(0.0, 0.0, 0.0), linestyle='-', linewidth=1)
    axes.set_ylim(ymin=0)
    axes.set_xlabel("Read Length (bp)")
    axes.set_ylabel("Density (Bases Read per Unit Read Length)")
    #axes.set_title("Base Yield Density")
    # compute fill regions
    xy_n50, xy_n95, xy_n100 = [], [], []
    for bin_midpoint, bin_height in zip(x, y):
        if bin_midpoint <= n50:
            xy_n50.append((bin_midpoint, bin_height))
        elif bin_midpoint <= n95:
            xy_n95.append((bin_midpoint, bin_height))
        else:
            xy_n100.append((bin_midpoint, bin_height))
    label_lines = []

    def _to_patch(verts, color, label=None):
        patch = Polygon(verts, facecolor=color)
        axes.add_patch(patch)
        if label is not None:
            mline = Line2D([], [], color=color, marker='s',
                           linestyle="None", label=label)
            label_lines.append(mline)
    if len(xy_n50) > 0:
        _to_patch([(x[0], 0)] + xy_n50 + [(xy_n50[-1][0], 0)], get_blue(4))
        if len(xy_n95) > 0:
            _to_patch([(xy_n50[-1][0], 0), xy_n50[-1]] + xy_n95
                      + [(xy_n95[-1][0], 0)], get_blue(2), ">= N50")
            if len(xy_n100) > 0:
                _to_patch([(xy_n95[-1][0], 0), xy_n95[-1]] + xy_n100
                          + [(xy_n100[-1][0], 0)], get_blue(0), ">= 95th percentile")
    axes.legend(handles=label_lines, loc="upper right", shadow=False)
    return _save_and_close(fig, png_file_name, dpi)


def plot_concordance_histogram(plot_x,
                               plot_y,
                               png_file_name,
                               xlabel="Concordance",
                               ylabel="Subreads",
                               title=None,
                               dpi=DEFAULT_DPI):
    """
    Plot a pre-computed histogram of fractional concordance values.
    """
    bin_width = 1 / float(Constants.NBINS_CONCORDANCE)
    fig, axes = get_fig_axes_lpr()
    axes.bar(plot_x, plot_y, width=bin_width,
             color=get_green(2), edgecolor=get_green(1))
    axes.set_xlabel(xlabel)
    axes.set_ylabel(ylabel)
    if title is not None:
        axes.set_title(title, fontsize=20)
    axes.set_xlim(plot_x[0] - bin_width, plot_x[-1] + bin_width)
    return _save_and_close(fig, png_file_name, dpi)


def plot_read_lengths_binned(bincounts,
                             png_file_name,
                             read_type="Read",
                             dpi=DEFAULT_DPI,
                             title=None,
                             color=get_green(1),
                             edgecolor=get_green(0)):
    """
    Plot a histogram of read lengths (of any type, defaulting to "Read")
    using a numpy.bincounts array as input.
    """
    max_length = len(bincounts)
    bin_size = get_read_length_histogram_bin_width(max_length)
    n_bins = int(math.ceil(float(max_length) / bin_size))
    plot_x = [k * bin_size for k in range(n_bins)]
    plot_y = rebin_histogram(bincounts, bin_size)
    fig, axes = get_fig_axes_lpr()
    axes.bar(plot_x, plot_y, width=bin_size * 0.95,
             color=color,
             edgecolor=edgecolor,
             linewidth=0.5)
    axes.set_xlabel("{t} Length (bp)".format(t=read_type))
    axes.set_ylabel("Number of {t}s".format(t=read_type))
    if title is not None:
        axes.set_title(title, fontsize=20)
    return _save_and_close(fig, png_file_name, dpi)


def plot_mapped_concordance_vs_read_length(read_length,
                                           concordance,
                                           png_file_name,
                                           dpi=DEFAULT_DPI,
                                           x_label="Alignment Length (bp)"):
    """
    Scatter plot equivalent to the old "rainbow" plot, except the QVs are no
    longer relevant in Sequel data.
    """
    fig, axes = get_fig_axes_lpr()
    axes.plot(read_length, concordance, 'o', c="#cb181d",
              mec="#cb181d", alpha=0.1, ms=2.0)
    axes.set_xlabel(x_label)
    axes.set_ylabel('Mapped Concordance')
    return _save_and_close(fig, png_file_name, dpi)


def plot_mapped_concordance_vs_read_length_hist2d(
        histogram,
        png_file_name,
        dpi=DEFAULT_DPI,
        x_label="Alignment Length (bp)",
        log_scale=False):
    """
    Plot a pre-calculated 2D histogram of mapped concordance vs. (sub)read
    length as a heatmap.
    """
    assert len(histogram) > 0
    histogram = histogram.crop()
    fig, axes = get_fig_axes_lpr()
    cmap = plt.cm.get_cmap("Spectral_r")
    cmap.set_under(color=(0.875, 0.875, 0.875))
    axes.patch.set_facecolor((0.875, 0.875, 0.875))
    xlim = histogram.xedges[0], histogram.xedges[-1]
    ylim = histogram.yedges[0], histogram.yedges[-1]
    # This has been visually confirmed to be consistent with a matplotlib
    # histogram of the same data.  It's still not totally obvious to me why
    # the transpose() is necessary.
    data = histogram.data.transpose()
    vmin = 0.1
    if log_scale:
        # https://stackoverflow.com/a/21753388
        np.seterr(divide="ignore")
        data = np.log10(data)
        np.seterr(divide="warn")
        vmin = 0
    im = axes.imshow(data,
                     origin="lower",
                     cmap=cmap,
                     extent=[xlim[0], xlim[1], ylim[0], ylim[1]],
                     aspect=(xlim[1] - xlim[0]) / (ylim[1] - ylim[0]),
                     vmin=vmin)
    axes.set_xlabel(x_label, fontsize=18)
    axes.set_ylabel('Mapped Concordance', fontsize=18)
    cbar = fig.colorbar(im, ax=axes, fraction=0.05, pad=0.01)
    cbar.ax.set_ylabel("Count", fontsize=18)
    if log_scale:
        cmin, cmax = cbar.get_clim()
        ticks = list(xrange(int(math.floor(cmin)), int(math.ceil(cmax))))
        ticks = [t / (cmax - cmin) for t in ticks]
        cbar.ax.get_yaxis().set_ticks(ticks)
        tick_labels = [str(int(np.round(10**(t * cmax)))) for t in ticks]
        cbar.ax.get_yaxis().set_ticklabels(tick_labels)
    fig.tight_layout()
    return _save_and_close(fig, png_file_name, dpi)


def plot_accuracy_vs_concordance(readQual,
                                 concordance,
                                 png_file_name,
                                 x_label="Predicted Accuracy",
                                 y_label="Mapped Concordance",
                                 dpi=DEFAULT_DPI):
    """
    Mapped QV Calibration from CCS Mapping report: scatter plot of readQual
    versus mapped concordance, with an X=Y line for reference.
    """
    fig, axes = get_fig_axes_lpr()
    axes.plot(readQual, concordance, '+', c=get_blue(3))
    xlim = axes.get_xlim()
    xy = np.linspace(xlim[0], xlim[1])
    axes.plot(xy, xy, '-', color='r')
    axes.set_xlabel(x_label, fontsize=18)
    axes.set_ylabel(y_label, fontsize=18)
    return _save_and_close(fig, png_file_name, dpi)
