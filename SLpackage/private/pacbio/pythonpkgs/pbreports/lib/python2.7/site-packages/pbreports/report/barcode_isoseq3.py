#! python

"""
Modified version of barcode report for use in Iso-Seq 3.
"""

from pprint import pformat
import functools
import logging
import json
import os.path as op
import sys

from pbcommand.models import DataStore, FileTypes
from pbcommand.models.report import PlotGroup
from pbcommand.cli import pbparser_runner
from pbcommand.utils import setup_log
from pbcore.io import ConsensusReadSet

from pbreports.report import barcode as barcode_report
from pbreports.report.barcode import read_inputs, get_barcode_info_parallel
from pbreports.io.barcode import get_unbarcoded_reads_info
from pbreports.io.specs import load_spec
from pbreports.plot.helper import to_plotgroup
from pbreports.plot.tools import plot_read_lengths_with_cdf

log = logging.getLogger(__name__)
__version__ = "0.3"


class Constants(barcode_report.Constants):
    TOOL_ID = "pbreports.tasks.barcode_isoseq3"
    TOOL_NAME = "barcode_isoseq3"
    DRIVER_EXE = "python -m pbreports.report.barcode_isoseq3 --resolved-tool-contract"
    VERSION = __version__
    DOC = __doc__
    FILE_TYPE_READS_IN = FileTypes.DS_CCS
    LABEL_NONE = "No Primer"
    NBINS_FLNC = 80

    A_NREADS_TOTAL = "n_reads_total"
    A_FL = "num_reads_fl"
    A_FLNC = "num_reads_flnc"
    A_FLNC_POLYA = "num_reads_flnc_polya"
    A_FLNC_RL = "mean_flnc_read_length"

    PG_READLENGTH = "fulllength_nonconcatemer_readlength_group"
    P_READLENGTH = "fulllength_nonconcatemer_readlength_hist"
    PNG_READLENGTH = "fulllength_nonconcatemer_readlength_hist.png"

    SHOW_COLUMNS = [
        barcode_report.Constants.C_BIOSAMPLE,
        barcode_report.Constants.C_IDX,
        barcode_report.Constants.C_BARCODE,
        barcode_report.Constants.C_NREADS,
        # barcode_report.Constants.C_NBASES,
        barcode_report.Constants.C_BCQUAL,
        barcode_report.Constants.C_RANK
    ]

    SHOW_ATTRIBUTES = [
        A_NREADS_TOTAL,
        A_FL,
        A_FLNC,
        A_FLNC_POLYA,
        barcode_report.Constants.A_NBARCODES,
        barcode_report.Constants.A_MEAN_READS,
        barcode_report.Constants.A_MAX_READS,
        barcode_report.Constants.A_MIN_READS,
        barcode_report.Constants.A_NREADS_UNBARCODED
    ]


def make_flnc_readlength_plot(flnc_reads, output_dir):
    with ConsensusReadSet(flnc_reads) as ccs_flnc:
        read_lengths = ccs_flnc.index.qEnd
        mean_length = int(read_lengths.mean()) if read_lengths.size > 0 else 0
        png, thumb = plot_read_lengths_with_cdf(
            read_lengths,
            op.join(output_dir, Constants.PNG_READLENGTH),
            bins=80)
        return to_plotgroup(Constants.PG_READLENGTH, Constants.P_READLENGTH, png, thumb), mean_length, ccs_flnc.uuid


make_report = functools.partial(barcode_report._make_report_impl,
                                Constants.SHOW_ATTRIBUTES,
                                Constants.SHOW_COLUMNS,
                                Constants.LABEL_NONE)


def run_to_report(ds_bc_file,
                  barcodes_file,
                  reads_in_file,
                  isoseq_stats,
                  flnc_reads,
                  base_dir=None,
                  datastore_json=None,
                  nproc=1):
    spec = load_spec("barcode_isoseq3")
    inputs = read_inputs(ds_bc_file, barcodes_file, reads_in_file)
    read_info, barcoded_zmws, biosamples, _, bc_dataset_uuids = get_barcode_info_parallel(
        inputs.ds_files,
        barcodes_file,
        nproc=nproc,
        isoseq_mode=True)
    read_info.extend(list(get_unbarcoded_reads_info(
        inputs.reads_in, barcoded_zmws, label_none=Constants.LABEL_NONE)))
    barcode_report.write_empty_datastore(datastore_json)
    attr_front = [
        (Constants.A_NREADS_TOTAL, len(read_info))
    ]
    with open(isoseq_stats, "r") as json_in:
        stats = json.loads(json_in.read())
        # the json output
        for key in [Constants.A_FL, Constants.A_FLNC, Constants.A_FLNC_POLYA]:
            attr_front.append((key, stats[key]))
    flnc_pg, flnc_rl, ccs_uuid = make_flnc_readlength_plot(flnc_reads, base_dir)
    attr_front.append((Constants.A_FLNC_RL, flnc_rl))
    rpt = make_report(biosamples=biosamples,
                      read_info=read_info,
                      bc_dataset_uuids=bc_dataset_uuids,
                      dataset_uuids=inputs.dataset_uuids,
                      base_dir=base_dir,
                      use_spec=spec,
                      with_attributes=attr_front)
    rpt.add_plotgroup(flnc_pg)
    # XXX this is sloppy but if we record the CCS UUID here the report ends up
    # being repeated in the dataset details page
    #rpt._dataset_uuids.append(ccs_uuid)
    return spec.apply_view(rpt)


def args_runner(args):
    log.info("Starting {f} version {v} report generation".format(
        f=__file__, v=__version__))
    report = run_to_report(args.ds_bc, args.barcodes, args.reads_in,
                           args.isoseq_stats,
                           args.flnc_reads,
                           base_dir=op.dirname(args.report_json),
                           nproc=args.nproc)
    log.info(pformat(report.to_dict()))
    report.write_json(args.report_json)
    return 0


def resolved_tool_contract_runner(rtc):
    log.info("Starting {f} version {v} report generation".format(
        f=__file__, v=__version__))
    report = run_to_report(
        ds_bc_file=rtc.task.input_files[0],
        barcodes_file=rtc.task.input_files[2],
        reads_in_file=rtc.task.input_files[1],
        isoseq_stats=rtc.task.input_files[3],
        flnc_reads=rtc.task.input_files[4],
        base_dir=op.dirname(rtc.task.output_files[0]),
        nproc=rtc.task.nproc)
    log.debug(pformat(report.to_dict()))
    report.write_json(rtc.task.output_files[0])
    report.tables[0].to_csv(rtc.task.output_files[1])
    return 0


def _get_parser():
    p = barcode_report.get_parser(Constants, include_datastore_json=False)
    p.add_input_file_type(
        FileTypes.JSON, "isoseq_stats", "Iso-Seq Summary", "Filtering Summary JSON from task isoseq3.tasks.cluster")
    p.add_input_file_type(
        FileTypes.DS_CCS, "flnc_reads", "FLNC CCS reads", "Full-length non-concatamer CCS reads")
    return p


def main(argv=sys.argv):
    return pbparser_runner(
        argv=argv[1:],
        parser=_get_parser(),
        args_runner_func=args_runner,
        contract_runner_func=resolved_tool_contract_runner,
        alog=log,
        setup_log_func=setup_log)


if __name__ == "__main__":
    sys.exit(main(sys.argv))
