
# FIXME this is impossibly inefficient at human scale; we need to do better
# than a scatter plot with 3 billion points

"""
Generates plots showing the distribution of kinetics across all bases, taken
from ipdSummary output.
"""

import collections
import logging
import gzip
import csv
import os
import sys

import numpy as np

from pbcommand.models.report import Report, PlotGroup, Plot
from pbcommand.models import FileTypes, get_pbparser
from pbcommand.cli import (pacbio_args_runner,
                           get_default_argparser_with_base_opts)
from pbcommand.utils import setup_log

import pbreports.plot.helper as PH
from pbreports.plot.helper import DEFAULT_DPI
from pbreports.util import Constants as BaseConstants
from pbreports.io.specs import *

log = logging.getLogger(__name__)

__version__ = '3.0'

spec = load_spec("modifications")


class Constants(BaseConstants):
    TOOL_ID = "pbreports.tasks.modifications_report"
    DRIVER_EXE = "python -m pbreports.report.modifications --resolved-tool-contract"
    PG_KIN = "kinetic_detections"
    P_SCAT = "kinetic_scatter"
    P_HIST = "kinetic_histogram"


def readModificationCsvGz(fn):

    def _open_file(file_name):
        if file_name.endswith(".gz"):
            return gzip.GzipFile(file_name)
        else:
            return open(file_name, "r")

    with _open_file(fn) as f:
        reader = csv.reader(f)

        records = []
        header = reader.next()

        colIdx = 0
        colMap = {}
        for h in header:
            colMap[h] = colIdx
            colIdx += 1

        # Read csv
        n = 0
        kinHit = collections.namedtuple("kinHit", "base coverage score")
        for row, record in enumerate(reader):
            if int(record[colMap['score']]) > 20:
                tupleRec = kinHit(base=record[colMap['base']], coverage=int(
                    record[colMap['coverage']]), score=int(record[colMap['score']]))
                records.append(tupleRec)
                n += 1

        # convert to recarray
        kinRec = [('base', '|S1'), ('coverage', '>i4'),
                  ('score', '>i4'), ('color', 'b')]
        kinArr = np.zeros(len(records), dtype=kinRec)
        idx = 0
        for rec in records:
            kinArr['base'][idx] = rec.base
            kinArr['coverage'][idx] = rec.coverage
            kinArr['score'][idx] = rec.score
            idx += 1

        return kinArr


def _create_fig_template(dims=(8, 6), facecolor='#ffffff', gridcolor='#e0e0e0'):
    fig, ax = PH.get_fig_axes_lpr(dims=dims)
    # ax = fig.add_subplot(111) # already add in helper.get_fig_axes()

    ax.patch.set_facecolor(facecolor)
    ax.grid(color=gridcolor, linewidth=0.5, linestyle='-')
    ax.set_axisbelow(True)
    PH.set_tick_label_font_size(ax, 12, 12)
    PH.set_axis_label_font_size(ax, 16)
    return fig, ax


def plot_kinetics_scatter(kinArr, ax):

    handles = []
    colors = ['red', 'green', 'blue', 'magenta']
    bases = ['A', 'C', 'G', 'T']

    for base, color in zip(bases, colors):
        baseHits = kinArr[kinArr['base'] == base]

        if baseHits.shape[0] > 0:
            # Add a bit of scatter to avoid ugly aliasing in plot due to
            # integer quantization
            cov = baseHits['coverage'] + 0.25 * \
                np.random.randn(baseHits.shape[0])
            score = baseHits['score'] + 0.25 * \
                np.random.randn(baseHits.shape[0])

            pl = ax.scatter(cov, score, c=color, label=base,
                            lw=0, alpha=0.3, s=12)
            handles.append(pl)

    ax.set_xlabel('Per-Strand Coverage')
    ax.set_ylabel('Modification QV')
    ax.legend(handles, bases, loc='upper left')

    if kinArr.shape[0] > 0:
        ax.set_xlim(0, np.percentile(kinArr['coverage'], 95.0) * 1.4)
        ax.set_ylim(0, np.percentile(kinArr['score'], 99.9) * 1.3)


def plot_kinetics_hist(kinArr, ax):

    colors = ['red', 'green', 'blue', 'magenta']
    bases = ['A', 'C', 'G', 'T']

    # Check for empty or peculiar modifications report:
    d = kinArr['score']
    if d.size == 0:
        binLim = 1.0
    elif np.isnan(np.sum(d)):
        binLim = np.nanmax(d)
    else:
        binLim = np.percentile(d, 99.9) * 1.2

    ax.set_xlim(0, binLim)
    bins = np.arange(0, binLim, step=binLim / 75)

    for base, color in zip(bases, colors):
        baseHits = kinArr[kinArr['base'] == base]
        if baseHits.shape[0] > 0:
            pl = ax.hist(baseHits['score'], color=color,
                         label=base, bins=bins, histtype="step", log=True)

    ax.set_ylabel('Bases')
    ax.set_xlabel('Modification QV')

    if d.size > 0:
        ax.legend(loc='upper right')


def get_qmod_plot(kinData, output_dir, dpi):
    """
    Return a plot object
    """
    fig, ax = _create_fig_template()

    plot_kinetics_scatter(kinData, ax)

    png_path = os.path.join(output_dir, "kinetic_detections.png")
    png, thumbpng = PH.save_figure_with_thumbnail(fig, png_path, dpi=dpi)

    return Plot(Constants.P_SCAT, os.path.basename(png),
                thumbnail=os.path.basename(thumbpng))


def get_qmod_hist(kinData, output_dir, dpi):
    """
    Return a plot object
    """
    fig, ax = _create_fig_template()

    plot_kinetics_hist(kinData, ax)

    png_path = os.path.join(output_dir, "kinetic_histogram.png")
    png, thumbpng = PH.save_figure_with_thumbnail(fig, png_path, dpi=dpi)

    return Plot(Constants.P_HIST, os.path.basename(png),
                thumbnail=os.path.basename(thumbpng))


def make_modifications_report(modifications_csv, report, output_dir, dpi=72, dumpdata=True):
    """
    Entry point to report generation.
    """

    kinData = readModificationCsvGz(modifications_csv)

    scatter = get_qmod_plot(kinData, output_dir, dpi)
    hist = get_qmod_hist(kinData, output_dir, dpi)

    pg = PlotGroup('kinetic_detections',
                   title='Kinetic Detections',
                   thumbnail=scatter.thumbnail,
                   plots=[scatter, hist])

    rpt = Report('modifications', title="Base Modifications",
                 plotgroups=[pg])
    rpt = spec.apply_view(rpt)
    rpt.write_json(os.path.join(output_dir, report))
    return 0


def run_args(args):
    return make_modifications_report(
        modifications_csv=args.basemods_csv,
        report=os.path.basename(args.report),
        output_dir=os.path.dirname(args.report))


def _get_parser():
    p = get_default_argparser_with_base_opts(
        version=__version__,
        description=__doc__,
        default_level="INFO")
    p.add_argument("basemods_csv",
                   help="CSV file of base modifications from ipdSummary")
    p.add_argument("report", help="Output report JSON")
    return p


def main(argv=sys.argv):
    return pacbio_args_runner(
        argv=argv[1:],
        parser=_get_parser(),
        args_runner_func=run_args,
        alog=log,
        setup_log_func=setup_log)


if __name__ == "__main__":
    sys.exit(main())
