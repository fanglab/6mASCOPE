"""
All util functions copied from mkocher pbcommand or pbcore
to reduce dependencise with slight modifications if needed.
"""
from __future__ import absolute_import

import os
import logging
import time
import argparse
import functools
import types
import subprocess

# List of important public functions.
#__all__ = [ "nfs_exists_check", "validate_file", "compose", "subparser_builder", "get_default_argparser", "setup_log", "main_runner"]

log = logging.getLogger()


def _validate_resource(func, resource):
    """Validate the existence of a file/dir"""
    if resource in ["-" or "stdin" or "stdout"]:  # stdin and stdout
        return "-"

    _ = nfs_exists_check(resource)

    if func(resource):
        return os.path.abspath(resource)
    else:
        raise IOError("Unable to find '{f}'".format(f=resource))


validate_file = functools.partial(_validate_resource, os.path.isfile)


def subparser_builder(subparser, subparser_id, description, options_func, exe_func, epilog):
    """
    Util to add subparser options

    :param subparser:
    :param subparser_id:
    :param description:
    :param options_func: Function that will add args and options to Parser instance F(subparser) -> None
    :param exe_func: Function to run F(args) -> Int
    :return:
    """
    p = subparser.add_parser(subparser_id, help=description, epilog=epilog)
    options_func(p)
    p.set_defaults(func=exe_func)
    return p

def args_executer(args):
    """
    :rtype int
    """
    try:
        return_code = args.func(args)
    except Exception as e:
        log.exception('Failed on {!r}({!r})'.format(args.func, args))
        import traceback
        traceback.print_exc(limit=100)
        if isinstance(e, IOError):
            return_code = 1
        else:
            return_code = 2

    return return_code


# copied from pbcommand.utils, to reduce dependencise
def nfs_exists_check(ff):
    """
    Central place for all NFS hackery

    Return whether a file or a dir ff exists or not.
    Call listdir() instead of os.path.exists() to eliminate NFS errors.

    Added try/catch black hole exception cases to help trigger an NFS refresh

    :rtype bool:
    """
    try:
        # All we really need is opendir(), but listdir() is usually fast.
        os.listdir(os.path.dirname(os.path.realpath(ff)))
        # But is it a file or a directory? We do not know until it actually
        # exists.
        if os.path.exists(ff):
            return True
        # Might be a directory, so refresh itself too.
        # Not sure this is necessary, since we already ran this on parent,
        # but it cannot hurt.
        os.listdir(os.path.realpath(ff))
        if os.path.exists(ff):
            return True
    except OSError:
        pass

    # The rest is probably unnecessary, but it cannot hurt.

    # try to trigger refresh for File case
    try:
        f = open(ff, 'r')
        f.close()
    except Exception:
        pass

    # try to trigger refresh for Directory case
    try:
        _ = os.stat(ff)
        _ = os.listdir(ff)
    except Exception:
        pass

    # Call externally
    # this is taken from Yuan
    cmd = "ls %s" % ff
    rcode = 1
    try:
        p = subprocess.Popen([cmd], shell=True)
        rcode = p.wait()
    except Exception:
        pass

    return rcode == 0


def compose(*funcs):
    """
    Functional composition of a non-empty list

    [f, g, h] will be f(g(h(x)))

    ..doctest::
        >>> f = lambda x: x * x
        >>> g = lambda x: x + 1
        >>> h = lambda x: x * 2
        >>> funcs = [f, g, h]
        >>> fgh = compose(*funcs)
        >>> fgh(3)
        49
        >>> compose(f, g, h)(3)
        49
    """
    if not funcs:
        raise ValueError("Compose only supports non-empty lists")
    for func in funcs:
        if not isinstance(func, (types.BuiltinMethodType,
                                 functools.partial,
                                 types.MethodType,
                                 types.BuiltinFunctionType,
                                 types.FunctionType)):
            raise TypeError("Only Function types are supported")

    def compose_two(f, g):
        """Compose two functions f, g to f(g(...))"""
        def c(x):
            return f(g(x))
        return c
    return functools.reduce(compose_two, funcs)


# functions for parsing args, setting up log and run main
def get_default_argparser(description, version):
    """Return argparser.ArgumentParser, with quiet, verbose and version"""
    p = argparse.ArgumentParser(description=description,
                                formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    p.version = version
    p.add_argument('--version', action="version", help='version')

    p.add_argument("--quiet", default=False,
                   action="store_true", help="Run silently")
    p.add_argument("--verbose", default=False,
                   action="store_true", help="Set the verbosity level to DEBUG")
    return p


def _get_log_level(args):
    """If args has quiet, return logging.ERROR.
    Otherwise, if args has verbose, return logging.DEBUG.
    Otherwise, return logging.INFO.
    """
    if hasattr(args, 'quiet') and args.quiet is True:  # quiet
        return logging.ERROR
    elif hasattr(args, 'verbose') and args.verbose is True:  # verbose
        return logging.DEBUG
    return logging.INFO


def setup_log(alog, args):
    """Setup stdout log."""
    log_level = _get_log_level(args)
    str_formatter = '[%(levelname)s] %(asctime)-15s [%(name)s %(funcName)s %(lineno)d] %(message)s'
    logging.basicConfig(level=log_level, format=str_formatter)
    logging.Formatter.converter = time.gmtime
    return alog


def main_runner(argv, parser, exe_runner_func, setup_log_func, alog):
    """Fundamental interface to commandline applications"""
    started_at = time.time()
    args = parser.parse_args(argv)
    log.info(args)

    setup_log_func(alog, args)
    run_time = time.time() - started_at
    rcode = exe_runner_func(args)

    _d = dict(r=rcode, s=run_time)
    alog.info("exiting with return code {r} in {s:.2f} sec.".format(**_d))
    return rcode


# Copied from pbcore.utils.Process
def backticks(cmd, merge_stderr=True):
    """
    Simulates the perl backticks (``) command with error-handling support
    Returns ( command output as sequence of strings, error code, error message )
    """
    if merge_stderr:
        _stderr = subprocess.STDOUT
    else:
        _stderr = subprocess.PIPE

    p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE, stderr=_stderr,
                         close_fds=True)

    out = [l[:-1] for l in p.stdout.readlines()]

    p.stdout.close()
    if not merge_stderr:
        p.stderr.close()

    # need to allow process to terminate
    p.wait()

    errCode = p.returncode and p.returncode or 0
    if p.returncode > 0:
        errorMessage = os.linesep.join(out)
        output = []
    else:
        errorMessage = ''
        output = out

    return output, errCode, errorMessage
