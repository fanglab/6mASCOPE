"""Define SvType, SvFmt, SvAnnot, SvAnnotations"""
from __future__ import absolute_import

import re
from .utils import items_to_str, revcomp, is_bed, is_interval
from collections import defaultdict


def rev_dict(d):
    """reverse map a dict, assuming that values are unique"""
    assert isinstance(d, dict)
    if len(set(d.values())) != len(d.keys()):
        raise ValueError("Values of input dict for rev_dict must be unique.")
    revd = dict()
    for k, v in d.iteritems():
        revd[v] = k
    return revd


def _f(x, t, s, cls):
    """Return True if x equals t,
    or x is an instance of cls and x equals cls(t),
    or x.lower().startswith(s)"""
    return x == t or \
            (isinstance(x, cls) and x == cls(t)) or \
            (isinstance(x, str) and x.lower().startswith(s))


class _SvEnumCls(object):
    """SV Enum class"""
    NAME2VAL = {}

    def __init__(self, _val):
        self.val = _val

    def __cmp__(self, other):
        if isinstance(other, int):
            return cmp(self.val, other)
        elif isinstance(other, _SvEnumCls):
            return cmp(self.val, other.val)
        else:
            raise TypeError("Could not compare %r with %r" %(other, self))

    def __getattr__(self, name):
        if name.startswith('is_') and name[3:] in self.NAME2VAL.keys():
            # define is_ attributes here.
            # e.g., is_Deletion, is_Insertion, is_Duplication, is_Inversion for SvType
            # e.g., is_ALU, is_L1, is_SVA_A for SvAnnot
            return self.val == self.NAME2VAL[name[3:]]
        else:
            raise AttributeError("Could not find attribute %s in class %r" %(
                                 name, self.__class__.__name__))

    def __str__(self):
        return rev_dict(self.NAME2VAL)[self.val]
    def __repr__(self):
        return '{}({!r})'.format(self.__class__.__name__, self.val)


class SvType(_SvEnumCls):

    """Enum for types of structural variant"""

    Deletion = 0
    Insertion = 1
    Duplication = 2
    Inversion = 3
    Bnd = 4

    NAME2VAL = {'Deletion': Deletion, 'Insertion': Insertion, 'Duplication': Duplication, 'Inversion': Inversion, 'Bnd': Bnd}
    VCFNAME2VAL = {'DEL': Deletion, 'INS': Insertion, 'DUP': Duplication, 'INV': Inversion, 'BND': Bnd}

    def __init__(self, _val):
        super(SvType, self).__init__(_val)
        if _val is SvType.Insertion or _val is SvType.Deletion or _val is SvType.Duplication or _val is SvType.Inversion:
            self.val = _val
            # for a clear cut-off of recursion
        elif _f(_val, SvType.Deletion, 'del', SvType):
            self.val = SvType.Deletion
        elif _f(_val, SvType.Insertion, 'ins', SvType):
            self.val = SvType.Insertion
        elif _f(_val, SvType.Duplication, 'dup', SvType):
            self.val = SvType.Duplication
        elif _f(_val, SvType.Inversion, 'inv', SvType):
            self.val = SvType.Inversion
        elif _f(_val, SvType.Bnd, 'bnd', SvType):
            self.val = SvType.Bnd
        else:
            raise ValueError("Unknown SV type %s" %_val)

    def to_bed_str(self):
        """To bed string, e.x., Deletion, Insertion, Duplication, Inversion, Bnd"""
        return self.__str__()

    def to_vcf_str(self):
        """To vcf string, e.x., DEL, INS, DUP, INV, BND"""
        return rev_dict(self.VCFNAME2VAL)[self.val]


def readcount_depth_percent_to_gt(readcount, depth, readpercentage):
    if readcount >= 2 and readpercentage >= 90:
        return "1/1"
    elif readcount >= 1:
        return "0/1"
    elif depth >= 1:
        return "0/0"
    else:
        return "./."


def _2gt(gt):
    #TODO: replace VCFIO by pysam io.
    """
    A genotype of 0/0 is a statement that the sample has a homozygous reference
    genotype. The implication is that there is evidence that supports the reference allele.

    A genotype of ./. is a statement that the genotype of the sample is unknown.
    It is used primarily in regions where there are zero (or at least very few) reads.
    If there is no coverage, it is best not to make an affirmative statement on genotype.

    Need to differentiate "./." from "0/0".

    "X/Y" representation assumes diploid, while 'X' is only valid for haploid. But pbsv
    does *not* support non-diploid structural variants.
    So *dropped* support for "0" and "1" as valid input genotypes

    0/1 -> 0; 1/1 -> 1
    """
    if str(gt) == '1/1': # basically the same as 0/0
        return 1, 1
    elif str(gt) == '0/1': # heterozygous
        return 0, 1
    elif str(gt) == '0/0': # homozygous
        return 0, 0
    elif str(gt) == './.': # genotype unknown, not enough coverage
        return '.', '.'
    raise ValueError("Could not parse genotype %s" %gt)


class SvFmt(object):
    """ SV Format, GT:AD:DP, e.x. 0/1:3:6
    ...doctest:
        >>> s = SvFmt('0/1', 3, 6)
        >>> s.gt == (0, 1), s.ad == 3, s.dp == 6
        (True, True, True)
        >>> s = SvFmt.fromString('0/1:3:6')
        >>> s.gt == (0, 1), s.ad == 3, s.dp == 6
        (True, True, True)
    """
    __sep__ = ':' # separator
    GT = 'GT'
    AD = 'AD'
    DP = 'DP'
    FMT = __sep__.join([GT, AD, DP])
    def __init__(self, gt, ad, dp):
        self.gt = _2gt(gt)
        self.ad = int(ad)
        self.dp = int(dp)

    @property
    def gt_str(self):
        return str(self.gt[0]) + '/' + str(self.gt[1])

    def __str__(self):
        return items_to_str([self.gt_str, str(self.ad), str(self.dp)], self.__sep__)

    @classmethod
    def fromString(cls, s):
        """Return a SvFmt object parsing from s"""
        try:
            fs = s.split(SvFmt.__sep__)
            return SvFmt(gt=fs[0], ad=fs[1], dp=fs[2])
        except Exception as e:
            raise ValueError("Could not parse as SvFmt object %r: %s" % (s, str(e)))


class SvFmts(object):
    """Sv Formats for multiple samples.
    '', e.x., '0/1:3:6\t0/1:5:10'
    """
    __sep__ = '\t' # separator
    def __init__(self, fmts, samples):
        if not len(fmts) == len(samples):
            raise ValueError("fmts %r do not match samples %r" % (fmts, samples))
        self.samples = samples
        self.fmts = fmts
        self._dict = dict(zip(samples, fmts))

    def __getitem__(self, sample):
        return self._dict[sample]

    def __str__(self):
        raise NotImplementedError()

    def __repr__(self):
        return items_to_str(["%s=%s" % (s, f) for (s, f) in zip(self.samples, self.fmts)], self.__sep__)

    def to_str(self, samples):
        for s in samples:
            if not s in self.samples:
                raise ValueError("Sample %r not in SvFmts.samples %r" % (s, self.samples))
        return items_to_str([self._dict[sample] for sample in samples], self.__sep__)

    @classmethod
    def fromString(cls, s, samples):
        """Return a SvFmts object parsing from s"""
        fmts = [SvFmt.fromString(item) for item in s.split(cls.__sep__)]
        try:
            return SvFmts(fmts=fmts, samples=samples)
        except Exception as e:
            raise ValueError("Could not parse as SvFmts object %r: %s" % (s, str(e)))

    @classmethod
    def fromDict(cls, d):
        """Return a SvFmts object from {sample: SvFmt obj}"""
        samples = d.keys()
        fmts = [SvFmt.fromString(str(d[sample])) for sample in d.keys()]
        return SvFmts(fmts=fmts, samples=samples)


class SvAnnot(_SvEnumCls):

    """Enum for structural variant annotation"""

    ALU = 0
    L1 = 1
    SVA_A = 2 # SINE-R, VNTR and Alu composite, type A
    TANDEM = 3 # Tandem repeats
    OTHER = 1000 # other

    NAME2VAL = {
                'ALU': ALU, 'L1': L1, 'SVA_A': SVA_A,  # orig spellings, and current attributes
                'TANDEM': TANDEM, 'OTHER': OTHER,
    }
    ALLNAME2VAL = dict(NAME2VAL)
    ALLNAME2VAL.update({
                'Alu': ALU, 'LINE1': L1, 'SVA': SVA_A,  # some alt spellings
    })
    MOBILE_E = [ALU, L1, SVA_A]

    def __init__(self, _val):
        super(SvAnnot, self).__init__(_val)
        if isinstance(_val, str) and _val.upper() in self.ALLNAME2VAL:
            self.val = self.ALLNAME2VAL[_val]
        elif isinstance(_val, int) and _val in range(0, self.TANDEM + 1):
            self.val = _val
        elif isinstance(_val, SvAnnot):
            self.val = _val.val
        else:
            self.val = self.OTHER # default annotation other

    def to_vcf_str(self):
        """String to display in vcf output"""
        if self.is_OTHER: # don't show unannotated instances
            return ''
        return super(SvAnnot, self).__str__()

    def to_bed_str(self):
        """String to display in bed output"""
        return self.to_vcf_str()

    def __str__(self):
        return super(SvAnnot, self).__str__()

    def __repr__(self):
        return self.__str__()

    @property
    def is_ME(self):
        """Is x a mobile element?"""
        return self.val in self.MOBILE_E


class SvAnnotations(object):
    """SV annotations."""
    __sep__ = ','

    def __init__(self, annotations=None):
        self.annotations = [] if annotations is None else sorted([SvAnnot(a) for a in annotations])

    def __getitem__(self, k):
        return self.annotations[k]

    def __eq__(self, other):
        if isinstance(other, list):
            return self.annotations == other
        elif isinstance(other, SvAnnotations):
            return self.annotations == other.annotations
        else:
            raise TypeError("Could not compare %r with %r" %(other, self))

    def to_bed_str(self):
        """To bed string, e.x., `SVANNOT=L1`, or `.` if no self.annotations is None or empty"""
        strs = [x.to_bed_str() for x in self.annotations if len(x.to_bed_str()) != 0]
        if not strs:
            return '.'
        else:
            return 'SVANN=%s' % (self.__sep__.join(strs))

    def to_vcf_str(self):
        """To vcf string, e.x., `SVANNOT=L1`, or `` if no self.annotations is None or empty"""
        strs = [x.to_vcf_str() for x in self.annotations if len(x.to_vcf_str()) != 0]
        if not strs:
            return ''
        else:
            return 'SVANN=%s' % (self.__sep__.join(strs))

    def __str__(self):
        strs = [str(x) for x in self.annotations if len(str(x)) != 0]
        if not strs:
            return 'SVANN=OTHER'
        else:
            return 'SVANN=%s' % (self.__sep__.join(strs))

    def __repr__(self):
        return self.__str__()

    @classmethod
    def fromString(cls, s):
        """parse sv annotations from a string"""
        if s.startswith('SVANN='):
            s = s[6:]
        if s == '.':
            s = ''
        annotations = [SvAnnot(x) for x in s.split(cls.__sep__)]
        return SvAnnotations(annotations=annotations)


class ReadSvWindow(object):
    """A window in a read alignment that might contain a structural variant.
    """
    def __repr__(self):
        return 'ReadSvWindow({!r}, {!r}, {!r}, {!r}, {!r}, {!r}, {!r}, {!r}, {!r}, {!r}, {!r}, {!r})'.format(
            self.read, self.readName, self.readStart, self.readEnd, self.readSeq, self.refName, self.refStart, self.refEnd, self.refSeq, self.coveringReads, self.svType, self.svLen)

    def __init__(self, read, readName, readStart, readEnd, readSeq, refName, refStart, refEnd, refSeq, coveringReads, svType, svLen):
        self.read = read
        self.readName = readName
        self.readStart = readStart
        self.readEnd = readEnd
        self.readSeq = readSeq
        self.refName = refName
        self.refStart = refStart
        self.refEnd = refEnd
        self.refSeq = refSeq
        self.coveringReads = coveringReads
        self.svType = svType
        self.svLen = svLen

        # Count the A,C,G,T in the reference and read sequences.
        basepairs = ("A","C","G","T")
        self._readBpCt = dict([(b,0) for b in basepairs + ("N",)])
        for b in readSeq:
            b = b if b in basepairs else "N" # treat non-ACGT as N
            self._readBpCt[b] += 1
        self._refBpCt = dict([(b,0) for b in basepairs + ("N",)])
        for b in refSeq:
            b = b if b in basepairs else "N" # treat non-ACGT as N
            self._refBpCt[b] += 1
        self._changedBpCt = {}
        for b in basepairs:
            self._changedBpCt[b] = self._readBpCt[b] - self._refBpCt[b]

    def similar(self, other, lengthWiggle, positionWiggle, basepairIdWiggle):
        """Determine if the read SV window `other` is similar to the window `self`.
        Two read SV windows are considered to be similar if:
            1. The SV types are identical.
            2. The SV lengths agree (percentage difference <= lengthWiggle)
            3. The reference start and end coordinates agree (absolute difference <= positionWiggle).
            4. The basepair changes from the reference sequence agree (basepair identity difference <= basepairIdWiggle)
        """
        if self.svType != other.svType:  # types differ
            return False
        if self.svType == SvType.Bnd:
            raise NotImplementedError('Not supporting similar of sv type Bnd')
        lengthDiff = 0 if self.svLen == other.svLen else 2.0 * \
            abs(self.svLen - other.svLen) / (self.svLen +
                                             other.svLen)  # self.svLen == other.svLen covers 0 == 0
        if lengthDiff > lengthWiggle:  # lengths differ
            return False
        # positions agree
        if self.refName != other.refName or abs(self.refStart - other.refStart) > positionWiggle or abs(self.refEnd - other.refEnd) > positionWiggle:
            return False
        if self.svType != SvType.Inversion: # require similar basepair content for deletions and insertions
            changedBpCtDiff = sum(
                [abs(self._changedBpCt[b] - other._changedBpCt[b]) for b in self._changedBpCt])
            changedBpCtSum = sum(
                [abs(self._changedBpCt[b]) + abs(other._changedBpCt[b]) for b in self._changedBpCt])
            if changedBpCtSum != 0 and (2.0 * changedBpCtDiff / changedBpCtSum) > basepairIdWiggle:
                return False
        return True

    def __cmp__(self, other):
        """Order by refName,refStart"""
        return cmp((self.refName, self.refStart), (other.refName, other.refStart))


class ReadSvWindowCluster(object):
    """A cluster of nearby, similar read SV windows."""
    def __repr__(self):
        return '\n'.join([repr(x) for x in self.windows])

    def __init__(self, windows):
        self.windows = []
        self._addWindows(windows)

    def _addWindows(self, windows):
        """Add additional read SV windows to the cluster."""
        for rw in windows:
            self.windows.append(rw)

    def overlaps(self, other, lengthWiggle, positionWiggle, basepairIdWiggle):
        """Determine if the cluster `other` overlaps the cluster `self`.  Two clusters
        are considered to overlap if any window from the first cluster is "similar" to
        any window from the other cluster."""
        for rwSelf in self.windows:
            for rwOther in other.windows:
                if rwSelf.similar(rwOther, lengthWiggle, positionWiggle, basepairIdWiggle):
                    return True
        return False

    def merge(self, other):
        """Merge another read SV window cluster into this one."""
        self._addWindows(other.windows)

    def toStructuralVariants(self, StructuralVariant, samples):
        """Summarize the read SV window cluster into structural variant calls (typically one
        but could be multiple).

        StructuralVariant: ctor, to which we will pass
          (refName, refStart, refEnd, svType, svLen, supportingReads, coveringReads, diffSeq)
        """
        result = set()

        # The current implementation is (dumb) simple: represent the cluster
        # with its median length window.
        # sort windows by (svLen, readName, original_index)
        windows = [ew[1] for ew in sorted(enumerate(self.windows), key=lambda ew: (ew[1].svLen, ew[1].readName, ew[0]))]
        mw = windows[int((len(windows) - 1) / 2)]
        supportingReads = set([w.read for w in self.windows])
        coveringReads = set()
        for w in self.windows:
            coveringReads.update(w.coveringReads)
        if mw.svType == SvType.Insertion:
            diffSeq = mw.readSeq
        elif mw.svType == SvType.Inversion:
            diffSeq = mw.refSeq
        elif mw.svType == SvType.Bnd:
            diffSeq = mw.refSeq
        elif mw.svType == SvType.Duplication:
            diffSeq = mw.refSeq # ref, b/c this is duplicated, right?
        elif mw.svType == SvType.Deletion:
            diffSeq = mw.refSeq # ref, not read!
        else:
            raise Exception('Unexpected SvType: {!r}'.format(mw.svType))
        sv = StructuralVariant(mw.refName, mw.refStart, mw.refEnd, mw.svType, mw.svLen, supportingReads, coveringReads, diffSeq, samples)
        result.add(sv)
        return result

    @property
    def maxRefStart(self):
        """The maximum (refName,refStart) of any window in the cluster"""
        return max([(w.refName, w.refStart) for w in self.windows])

    @property
    def minRefStart(self):
        """The minimum (refName,refStart) of any window in the cluster"""
        return min([(w.refName, w.refStart) for w in self.windows])


class RefRegion(object):
    """
    ..doctest::
        >>> RefRegion.REGPATTERN.search('chr1:0-100').groups()
        ('chr1', '0', '100', None, None, None)
        >>> RefRegion.REGPATTERN.search('chr1:1-100').groups()
        ('chr1', '1', '100', None, None, None)
        >>> RefRegion.REGPATTERN.search('chr1:0').groups()
        (None, None, None, 'chr1', '0', None)
        >>> RefRegion.REGPATTERN.search('chr1').groups()
        (None, None, None, None, None, 'chr1')
        >>> RefRegion.REGPATTERN.search('chr1 ?')
    """
    STRPATTERN = r'^(\S+):(\d+)-(\d+)$|^(\S+):(\d+)$|^(\S+)$'
    REGPATTERN = re.compile(STRPATTERN)

    BED_STRPATTERN = r'^(\S+)\t(\d+)\t(\d+)$|^(\S+)\t(\d+)$|^(\S+)$'
    BED_REGPATTERN = re.compile(BED_STRPATTERN)

    def __init__(self, name, start=None, end=None):
        """start and end are 0 based, half-open."""
        self.name = name
        self.start = int(start) if start is not None else None
        self.end = int(end) if end is not None else None

    def slop(self, size, max_ref_len=None):
        """Slop this object to both ends by size bp.
        max_ref_len --- maximum reference length if not None
        This is the same as 'bedtools slop'.
        http://bedtools.readthedocs.io/en/latest/content/tools/slop.html

        ...doctest:
            >>> r = RefRegion('chr', 0,  100)
            >>> str(r.slop(0)), str(r.slop(10)), str(r.slop(10, 50))
            ('chr:1-100', 'chr:1-110', 'chr:1-50')
            >>> r.slop(0).start
            0
        """
        assert max_ref_len is None or self.start < max_ref_len, \
                'RefRegion start {} must be less than maximum reference length {}'.\
                format(self.start, max_ref_len)
        start = max(0, self.start - size) if self.start is not None else None

        end = min(self.end + size, max_ref_len) \
                if (self.end is not None and max_ref_len is not None) else \
                max_ref_len if self.end is None else (self.end + size)
        return RefRegion(self.name, start, end)

    def is_mergable(self, other):
        """Return True if two RefRegion objects are mergable"""
        return (self.name == other.name and max(self.start, other.start) <= min(self.end, other.end))

    def merge(self, other):
        """Object other must be mergable with this object, return the merged obj"""
        assert self.is_mergable(other)
        return RefRegion(self.name, min(self.start, other.start), max(self.end, other.end))

    def __str__(self):
        """Return representation string as an Interval, using 1 based, closed coordinate"""
        ret = "%s" % self.name
        if self.start is not None:
            ret += ":%s" % (self.start + 1)
        if self.end is not None:
            ret += "-%s" % self.end
        return ret

    def __repr__(self):
        return '<RefRegion {}>'.format(self.__str__())

    @classmethod
    def _fromString(cls, s, regpattern, strpattern):
        """Convert a string of regpattern to RefRegion"""
        s = s.replace(',', '') # ignore comma e.g., chr1\t10000\t20000, or chr1:10000-20000
        m = regpattern.search(s)
        if m:
            gs = m.groups()
            if gs[0] is not None:
                return RefRegion(gs[0], gs[1], gs[2])
            elif gs[3] is not None:
                return RefRegion(gs[3], gs[4], None)
            else:
                assert gs[5] is not None
                return RefRegion(gs[5], None, None)
        raise ValueError("Reference region %s does not match %s" % (s, strpattern))

    @classmethod
    def fromBedString(cls, s):
        """Convert REFNAME\tSTARTPOS\tENDPOS to RefRegion(name, start, end)"""
        return cls._fromString(s, cls.BED_REGPATTERN, 'REFNAME\\tSTARTPOS\\tENDPOS')

    @classmethod
    def fromIntervalString(cls, s):
        """Convert REFNAME[:STARTPOS[-ENDPOS]] to RefRegion(name, start, end),
        then convert 1 based, closed coordinate system to 0 based, half open system.
        """
        ret = cls._fromString(s, cls.REGPATTERN, 'REFNAME[:STARTPOS[-ENDPOS]]')
        if ret.start is not None:
            if ret.start <= 0:
                raise ValueError('Illigal Interval start {}, must conform to 1 based coordinate.'.format(ret.start))
            ret.start -= 1 # 1 based to 0 based
        return ret


def to_ref_regions(s_or_fn):
    """
    Input s can either a semicolon-delimited string or a BED file or a Interval file.
    * if s is an empty string or None, return [].
    * if s ends with '.bed', it is a BED file of newline-delimited REFNAME[\tSTARTPOS[\tENDPOS]]
    * if s ends with '.interval, it is a .interval file of newline-delimited REFNAME[:STARTPOS[-ENDPOS]]
    * otherwise, s is a semicolon-delimited string, convert the string to a list of reference regions,
    where each region is of format REFNAME[:STARTPOS[-ENDPOS]]

    s_or_fn --- either a BED file or a Interval file or a semicolon-delimited string

    .. doctest:: >>> [(r.name, r.start, r.end) for r in to_ref_regions('chr1:1-1000,000;chr2;chr3:2')]
        [('chr1', 1, 1000000), ('chr2', None, None), ('chr3', 2, None)]
    """
    assert not ' ' in s_or_fn
    if not s_or_fn:
        return []
    elif is_bed(s_or_fn):
        return [RefRegion.fromBedString(x.strip()) for x in open(s_or_fn, 'r').readlines()]
    elif is_interval(s_or_fn):
        return [RefRegion.fromIntervalString(x.strip()) for x in open(s_or_fn, 'r').readlines()]
    return [RefRegion.fromIntervalString(x.strip()) for x in s_or_fn.split(';')]


def consolidate_ref_regions(ref_regions, name_to_id_f=str):
    """
    name_to_id_f --- name_to_id_f(name) returns index of name
    """
    nameidset = set() # a set of name ids
    ret = defaultdict(list)
    # a dict of {nameid: list}, where list is a list of
    # (nameid, start, RefRegion object) tuples
    key = lambda r:(name_to_id_f(r.name), r.start)
    for r in sorted(ref_regions, key=key):
        nameid = name_to_id_f(r.name)
        _insert_ref_regions(ret[nameid], r, key=key)
        nameidset.add(nameid) # update nameid set
    # return ref regions in sorted order, sort by ref name, start
    return [r for nameid in sorted(nameidset) for _, _, r in ret[nameid]]


def _insert_ref_regions(ref_regions, new_r, key):
    """Insert a new RefRegion object to a list of existing ref_regions,
    ref_regions --- a sorted list of RefRegion objects.
    new_r --- a new RefRegion object, must be greater than or equal to the
       largest object in sorted ref_regions
    """
    def g(r):
        ref_regions.append(key(r) + (r, ))

    if len(ref_regions) == 0:
        g(new_r)
    else:
        # check if new_r can merge with existing RefRegion objects
        _, _, old_r = ref_regions.pop()
        if old_r.is_mergable(new_r):
            g(old_r.merge(new_r))
        else:
            g(old_r)
            g(new_r)
