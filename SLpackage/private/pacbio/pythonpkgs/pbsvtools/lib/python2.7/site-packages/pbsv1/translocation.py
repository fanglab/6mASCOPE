#! python

from __future__ import absolute_import

from collections import defaultdict, deque
from .aln.utils import get_query_start_end_in_forward_read
from .independent.utils import readname2zmwname, zmwname2moviename, is_bed, is_vcf, is_bam
from .independent.common import (SvType, SvFmt, SvFmts, readcount_depth_percent_to_gt,
        RefRegion)
from .io.VcfIO import *
from .libs import Fastafile
from .io.bamstream import (json_to_moviename_sample_dict, header_is_sorted_by_coordinate,
        _open_sam, sanitize_ref_regions)
from . import Constants as C
import re
import sys

import logging

log = logging.getLogger()
# Define coords
from .inversion import (IDX, ISREVERSE, REF_NAME, REF_START, REF_END,
        READ_START, READ_END, aln_to_coord_tuple, tag_inversions)
# aln_to_coord_tuple(aln, aln_id):
# convert aln to (IDX, ISREVERSE, REF_START, REF_END, READ_START, READ_END)

"""
Find and tag translocation alignments.
"""

TRANSLOCATION_TAG_NAME = 'tl'
TRANSLOCATION_TAG_TYPE = 'Z'

SEP_BETWEEN_TRANSPATHS = ';'
SEP_WITHIN_A_TRANSPATH = '='
SEP_READNAME_TRANSPATHS = '\t'

class TreeNode(object):

    def __init__(self, data, parent, first_child, next_sibling):
        self.data = data
        self.parent = parent # a TreeNode object or None
        self.first_child = first_child # a TreeNode object, or None
        self.next_sibling = next_sibling # a TreeNode object or None

    def __repr__(self):
        def f(n):
            return None if not n else n.data
        return '<TreeNode {!r}, parent={!r}, first_child={!r}, next_sibling={!r}>'.format(
                self.data, f(self.parent), f(self.first_child), f(self.next_sibling))

    @property
    def node_type(self):
        if self.is_root:
            return 'ROOT'
        elif self.is_leaf:
            return 'LEAF'
        else:
            return 'INTE'

    @property
    def is_root(self):
        return self.parent is None

    @property
    def is_leaf(self):
        return self.first_child is None

    @property
    def has_next_sibling(self):
        return self.next_sibling is not None

    @property
    def children(self):
        if self.is_leaf:
            return []
        assert self.first_child is not None
        ret = [self.first_child]
        node=ret[-1]
        while node.has_next_sibling:
            ret.append(node.next_sibling)
            node=ret[-1]
        return ret


    @property
    def last_child(self):
        if self.is_leaf:
            return None
        node = self.first_child
        while node.has_next_sibling:
            node = node.next_sibling
        return node

    def create_child_node_given_data(self, child_node_data):
        node = TreeNode(child_node_data, self, None, None)
        if self.first_child is None:
            self.first_child = node
        else:
            self.last_child.next_sibling = node

    def create_next_sibling_given_data(self, sibling_node_data):
        assert not self.has_next_sibling
        self.next_sibling = TreeNode(sibling_node_data, self.parent, None, None)

    @property
    def to_string(self):
        first_child = self.first_child.to_string if self.first_child else 'None'
        next_sibling = self.next_sibling.to_string if self.has_next_sibling else 'None'
        ret = '[{}, {}, {}]'.format(self.data, first_child, next_sibling)
        return ret

    @classmethod
    def from_string_and_parent(cls, s, parent):
        fs = eval(s)
        data, _first_child, _next_sibling = fs[0], fs[1], fs[2]
        # if parent is None: # no parent, no next sibling
        #    assert _next_sibling is None, 'No parent, no sibling'
        ret = TreeNode(data=data, parent=parent, first_child=None, next_sibling=None)
        first_child = TreeNode.from_string_and_parent(str(_first_child), ret) if _first_child  else None
        ret.first_child = first_child
        next_sibling = TreeNode.from_string_and_parent(str(_next_sibling), parent) if _next_sibling  else None
        ret.next_sibling = next_sibling
        return ret

    @property
    def to_root(self):
        ret=[self]
        node=ret[-1]
        while(node.parent):
            ret.append(node.parent)
            node=node.parent
        return ret


class Tree(object):
    """
    ... doctest:
    >>> s='[1, [2, None, [3, None, [4, None, None]]], None]'
    >>> t=Tree.from_string(s)
    >>> t.to_string==s
    True
    >>> [c.data for c in t.root.children]
    [2, 3, 4]
    >>> t = Tree()
    >>> t.create_root_given_data(1)
    >>> t.to_string
    '[1, None, None]'
    >>> t.root.children == []
    True

    """
    def __init__(self):
        self.root = None

    def create_root_given_data(self, data):
        assert self.root is None
        self.root = TreeNode(data=data, parent=None, first_child=None, next_sibling=None)

    def dfs(self):
        """
        Traverse the tree in order such that
        * a node will only be visited when either it is a leaf node
        * or all its children node have been visited.
        """
        visited = defaultdict(int)
        d = deque()
        d.append(self.root)
        ret = []
        while(len(d) > 0):
            node = d.pop()
            if node.is_leaf or all([visited[c] for c in node.children]):
                ret.append(node)
                visited[node] = 1
            else:
                d.append(node)
                for c in node.children:
                    if visited[c] != 1:
                        d.append(c)

            if node.has_next_sibling and visited[node.next_sibling] != 1:
                d.append(node.next_sibling)
        return ret

    @property
    def leaves(self):
        ret=[]
        for node in self.dfs():
            if node.is_leaf:
                ret.append(node)
        return ret

    @property
    def to_string(self):
        """Convert this tree to a string."""
        return self.root.to_string

    @classmethod
    def from_string(cls, s):
        node = TreeNode.from_string_and_parent(s, None)
        ret = Tree()
        ret.root = node
        return ret


def tag_translocations(alns, translocation_poswiggle, out_handler_f=None):
    """
    Find and tag translocations.
    """
    if len(alns) <= 1:
        return False
    # convert alignments to coords and sort by READ_START.
    coords = sorted([aln_to_coord_tuple(aln, idx) for (idx, aln) in enumerate(alns)], key=lambda c:c[READ_START])
    # test all combinations of coords to detect translocations
    transtree = Tree()
    transtree.create_root_given_data(data=coords[0])
    for idx, c0 in enumerate(coords):
        if idx == 0:
            continue
        nodes = transtree.dfs()
        for node in nodes:
            c1 = node.data
            if are_coords_adjacent_in_read(c0, c1, translocation_poswiggle):
                node.create_child_node_given_data(c0)
                break
    coords_lists = transtree_to_coords_lists(transtree)
    transpaths = [coords_list_to_transpath(coords_list) for coords_list in coords_lists]
    if len(transpaths):
        s = transpaths_to_string(transpaths)
        if out_handler_f:
            out_handler_f(SEP_READNAME_TRANSPATHS.join([aln.query_name, s]))
        for aln in alns: # tag all alignments
            set_translocation_tag(aln, s)


def transpaths_to_string(transpaths):
    """
    transpaths --- a list of transpath, where each transpath contains multiple transedges
    and each transedge connects two breakpoints, and adjacent transedges share start and
    end of an alignment.
    ...doctest:
        >>> c0 = (1, False, 'chr1', 0, 100, 0, 100)
        >>> c1 = (1, False, 'chr10', 200, 300, 100, 200)
        >>> c2 = (1, False, 'chr17', 1300, 1400, 100, 200)
        >>> c3 = (1, False, 'chr8', 700, 800, 300, 400)
        >>> coords_lists = [[c0, c1], [c0, c2, c3]]
        >>> transpaths = [coords_list_to_transpath(coords_list) for coords_list in coords_lists]
        >>> transpaths_to_string(transpaths)
        '(chr1,100,0,chr10,200,1);(chr1,100,0,chr17,1300,1)=(chr17,1400,0,chr8,700,1)'
    """
    return SEP_BETWEEN_TRANSPATHS.join([transpath_to_string(transpath) for transpath in transpaths])


def transpath_to_string(transpath):
    ret = []
    for transedge in transpath:
        t = TransEdge.from_tuple(transedge) if isinstance(transedge, tuple) else transedge
        ret.append(t.to_string)
    return SEP_WITHIN_A_TRANSPATH.join(ret)


class TransEdge(object):

    def __init__(self, chr0, bp0, is_start0, chr1, bp1, is_start1):
        self.chr0 = str(chr0)
        self.bp0 = int(bp0)
        self.is_start0 = onezero_to_truefalse(is_start0)
        self.chr1 = str(chr1)
        self.bp1 = int(bp1)
        self.is_start1 = onezero_to_truefalse(is_start1)

    def __repr__(self):
        return self.to_string

    def flip(self):
        """Flip two breakends"""
        return TransEdge(self.chr1, self.bp1, self.is_start1,
                         self.chr0, self.bp0, self.is_start0)

    @property
    def cmp_key(self):
        if self.chr0 < self.chr1 or (self.chr0 == self.chr1 and self.bp0 <= self.bp1):
            return (self.chr0, self.bp0, self.chr1, self.bp1)
        else:
            return (self.chr1, self.bp1, self.chr0, self.bp0)

    @property
    def to_tuple(self):
        return (self.chr0, self.bp0, self.is_start0, self.chr1, self.bp1, self.is_start1)

    @property
    def altfmt(self):
        return _to_altfmt(self.is_start0, self.is_start1)

    def alt(self, tbase):
        p = '{}:{}'.format(self.chr1, self.bp1)
        return self.altfmt.format(t=tbase, p=p)

    @property
    def to_string(self):
        return '({},{},{},{},{},{})'.format(self.chr0, self.bp0, truefalse_to_10(self.is_start0),
                self.chr1, self.bp1, truefalse_to_10(self.is_start1))

    @classmethod
    def from_two_coords(self, c0, c1):
        chr0, bp0, is_start0, chr1, bp1, is_start1 = get_transedge_from_two_coords(c0, c1)
        return TransEdge(chr0, bp0, is_start0, chr1, bp1, is_start1)

    @classmethod
    def from_tuple(self, t):
        return TransEdge(t[0], t[1], t[2], t[3], t[4], t[5])

    @classmethod
    def from_vcfrecord(self, r):
        chr1, bp1, tbase, is_start0, is_start1 = _from_altfmt(r.alt)
        return TransEdge(r.chrom, r.pos, is_start0, chr1, bp1, is_start1)

    @classmethod
    def from_bedrecord(self, r):
        chr1, bp1, tbase, is_start0, is_start1 = _from_altfmt(r.alt)
        return TransEdge(r.chrom, r.start, is_start0, chr1, bp1, is_start1)

    @classmethod
    def from_string(self, s):
        """Convert a string e.g.,
        (chr1,100,0,chr10,300,1) to TransEdge('chr1', 0, False, 'chr2', 100, True)
        """
        pattern_string = r"^(\((\w+),(\d+),(0|1),(\w+),(\d+),(0|1)\))$"
        pattern = re.compile(pattern_string)
        try:
            fs = pattern.search(s.strip()).groups()[1:7]
        except Exception as e:
            errmsg = "transpath string {} does not conform to {} e.g.,'(chr1,100,0,chr10,300,1,A,G)'"\
                    .format(s, pattern_string)
            raise ValueError(errmsg + str(e))
        return TransEdge(fs[0], fs[1], fs[2], fs[3], fs[4], fs[5])


def coords_list_to_transpath(coords_list):
    """
    Convert a list of coords to a transpath where each transpath may contain
    one or more transedges, where each transedge connects two break points.
    ...doctest:
        >>> c0 = (1, False, 'chr1', 0, 100, 0, 100)
        >>> c1 = (1, False, 'chr10', 200, 300, 100, 200)
        >>> c2 = (1, False, 'chr7', 800, 900, 200, 300)
        >>> s0 = "(chr1,100,1,chr10,200,0)=(chr10,300,0,chr7,800,1)"
        >>> coords_list_to_transpath([c0, c1, c2])
        [('chr1', 100, False, 'chr10', 200, True), ('chr10', 300, False, 'chr7', 800, True)]
        >>> c3 = (1, True, 'chr10', 200, 300, 200, 100)
        >>> coords_list_to_transpath([c0, c3, c2])
        [('chr1', 100, False, 'chr10', 300, False), ('chr10', 200, True, 'chr7', 800, True)]
    """
    ret = []
    for index in range(1, len(coords_list)):
        c0, c1 = coords_list[index-1], coords_list[index]
        ret.append(get_transedge_from_two_coords(c0, c1))
    return ret

def truefalse_to_10(truefalse):
    d = {True: 1, False: 0}
    return d[truefalse]

def onezero_to_truefalse(onezero):
    d = {1: True, '1': True, 0: False, '0': False, True:True, False: False}
    return d[onezero]


def string_to_transpath(s):
    """
    Convert a string to a transpath. e.g., convert
        (chr1,100,0,chr10,300,1)=(chr10,200,1,chr7,800,0)
    to a list of transedge tuples
        [('chr1', 100, False, 'chr10', 300, True)
         ('chr10', 200, True, 'chr7', 800, Fasle)]
    """
    return [TransEdge.from_string(x.strip()).to_tuple for x in s.split(SEP_WITHIN_A_TRANSPATH)]


def string_to_transpaths(s):
    """
    Convert a string to a list of transpaths.
    e.g., (chr1,100,0,chr10,300,1)=(chr10,200,1,chr7,800,0)=(chr5,0,0,chr8,100,0)
    """
    return [string_to_transpath(x) for x in s.split(SEP_BETWEEN_TRANSPATHS)]


def is_closed_transpath(transpath, poswiggle):
    """Return true if input transpath is closed (A--> B -->...--> A). Otherwise, return False if
    input transpat is half open (A-->B-->unknown)."""
    assert isinstance(transpath, list)
    assert len(transpath) >= 2
    return are_coords_adjacent_in_read(transpath[0], transpath[-1], poswiggle)


def transtree_to_coords_lists(transtree):
    """
    Each leaf represents a list of translocations of shown by the read.
    For each leaf, return a list of two or more coords from root to the leaf.
    """
    ret=[]
    for leaf in transtree.leaves[::-1]:
        nodes = leaf.to_root[::-1]
        if len(nodes)>=2:
            ret.append([node.data for node in nodes])
    return ret


def aln_has_translocations(aln):
    """Return True if input aln has translocation tags."""
    return aln.has_tag(TRANSLOCATION_TAG_NAME) and len(aln.get(TRANSLOCATION_TAG_NAME))

def get_transpaths_from_aln(aln):
    assert aln_has_translocations(aln)
    return string_to_transpaths(aln.get(TRANSLOCATION_TAG_NAME))


def transedge_cmp_key(transedge):
    """Return transedge comparison key"""
    if isinstance(transedge, tuple):
        return TransEdge.from_tuple(transedge).cmp_key
    elif isinstance(transedge, TransEdge):
        return transedge.cmp_key
    assert False


def to_transedge(transedge_or_tuple):
    return transedge_or_tuple if \
            isinstance(transedge_or_tuple, TransEdge) \
            else TransEdge.from_tuple(transedge_or_tuple)


def distance_between_smaller_endpoints_of_transedges(lhs, rhs):
    """
    If 'smaller' endpoints of lhs and rhs are on the same chromosome,
    return their distance, otherwise, return maxint.
    """
    lhs, rhs = to_transedge(lhs), to_transedge(rhs)
    lhschr0, lhsbp0 = lhs.cmp_key[0:2]
    rhschr0, rhsbp0 = rhs.cmp_key[0:2]
    if lhschr0 != rhschr0:
        return sys.maxint
    else:
        return abs(lhsbp0 - rhsbp0)


def are_transedges_similar(lhs, rhs, position_wiggle):
    """
    Given two transedge tuples, compare break points and return True if
    they are similar.

    ...doctest:
        >>> t0 = ('chr1', 100, False, 'chr10', 200, False)
        >>> t1 = ('chr10', 200, False, 'chr1', 100, False)
        >>> are_transedges_similar(t0, t1, 0)
        True
        >>> t2 = ('chr1', 200, False, 'chr10', 100, False)
        >>> are_transedges_similar(t0, t2, 10)
        False
        >>> t3 = ('chr1', 200, False, 'chr1', 100, False)
        >>> t4 = ('chr1', 100, False, 'chr1', 200, False)
        >>> are_transedges_similar(t3, t4, 10)
        True
        >>> t4 = ('chr17', 39120756, True, 'chr8', 120538907, True)
        >>> t5 = ('chr17', 39120760, True, 'chr8', 120538708, True)
        >>> are_transedges_similar(t4, t5, 200)
        True
    """
    # print('comparing {} and {}'.format(lhs, rhs))
    lhschr0, lhsbreakpoint0, lhschr1, lhsbreakpoint1 = transedge_cmp_key(lhs)
    rhschr0, rhsbreakpoint0, rhschr1, rhsbreakpoint1 = transedge_cmp_key(rhs)
    return (lhschr0 == rhschr0 and lhschr1 == rhschr1 and
            are_points_adjacent(lhsbreakpoint0, rhsbreakpoint0, position_wiggle) and
            are_points_adjacent(lhsbreakpoint1, rhsbreakpoint1, position_wiggle))


def is_transedge_similar_to_any(transedge, other_transedges, position_wiggle):
    """Return True if input transedge is similar to any transedge in other_transedges"""
    for other in other_transedges:
        if are_transedges_similar(transedge, other, position_wiggle):
            return True
    return False

def set_translocation_tag(aln, s):
    aln.set_tag(TRANSLOCATION_TAG_NAME, s, value_type=TRANSLOCATION_TAG_TYPE)


def are_points_adjacent(p0, p1, poswiggle):
    """Return True if two points are adjacent to each other"""
    return  abs(p0 - p1) <= abs(poswiggle)


def are_coords_majority_overlap_in_read(c0, c1, min_overlap_ratio=0.5):
    """Return True if majority of two coords overlap with each other in
    read coordinates.
    """
    min_read_len = min(c0[READ_END]-c0[READ_START], c1[READ_END]-c1[READ_START]) # min read length
    overlap = min(c0[READ_END], c1[READ_END]) - max(c0[READ_START], c1[READ_START]) # overlapping length
    return overlap >= min_overlap_ratio * min_read_len


def are_coords_adjacent_in_read(c0, c1, poswiggle):
    """Return True if two coords are adjacent to each other in
    read coordinates and do not majority overlap with each other in
    read coordinates.
    Allow
        ---------                   or      --------
               --------                               -----
    Not allow
         -----------------        nor     -------------------
                  ---------                         -------
    """
    adjacent = are_points_adjacent(p0=min(c0[READ_END], c1[READ_END]),
            p1=max(c0[READ_START], c1[READ_START]), poswiggle=poswiggle)
    overlap = are_coords_majority_overlap_in_read(c0, c1)
    return adjacent and not overlap


def get_transedge_from_two_coords(c0, c1):
    """
    Return translocation edge of c0 and c1 in reference coordinates.
    A translocation edge is a tuple connecting two break points:
    (FROM_REF_NAME, FROM_REF_POS, FROM_ALN_START, TO_REF_NAME, TO_REF_POS, TO_ALN_START)
    where, c0 must be adjacent to c1 in read coordinates and
           c0 must be to the left of c1 in read coordinates.
    """
    # assert are_coords_adjacent_in_read(c0, c1, poswiggle)
    assert c0[READ_START] <= c1[READ_START]
    bp0, is_start0 = (c0[REF_END], False) if not c0[ISREVERSE] else  (c0[REF_START], True)
    bp1, is_start1 = (c1[REF_START], True) if not c1[ISREVERSE] else (c1[REF_END], False)
    return (c0[REF_NAME], bp0, is_start0, c1[REF_NAME], bp1, is_start1)


def read_from_transpaths_sstream(reader):
    """
    Return
        transedges_to_readnames ---
        transpaths --- a list of transpath objects where each transpath contains
                       one or multiple transedges
    ...doctest:
        >>> s0= '(chr1,100,1,chr10,200,1);(chr1,500,0,chr17,1300,1)=(chr17,1400,0,chr8,700,0)'
        >>> s1= '(chr1,100,1,chr10,200,1);(chr1,500,0,chr17,1300,1)'
        >>> s2= '(chr1,500,0,chr17,1300,1)=(chr17,1400,0,chr8,700,0)'
        >>> reader = ['r{}\\t{}'.format(i, s) for i, s in enumerate([s0, s1, s2])]
        >>> o0, o1 = read_from_transpaths_sstream(reader)
        >>> e0 = ('chr1', 100, True, 'chr10', 200, True)
        >>> e1 = ('chr1', 500, False, 'chr17', 1300, True)
        >>> e2 = ('chr17', 1400, False, 'chr8', 700, False)
        >>> set01, set02, set012 = set(['r0', 'r1']), set(['r0', 'r2']), set(['r0', 'r1', 'r2'])
        >>> o0[e0] == set01 and o0[e1] == set012 and o0[e2] == set02
        True
        >>> o1 == [ [e0], [e1, e2], [e0], [e1], [e1, e2] ]
        True
    """
    transedge_to_readnames = defaultdict(set)
    transpaths = []

    for r in reader:
        if r.startswith('#') or not len(r.strip()):
            continue
        readname, transpaths_string = r.strip().split(SEP_READNAME_TRANSPATHS)
        _transpaths = string_to_transpaths(transpaths_string)
        for transpath in _transpaths:
            for transedge in transpath:
                transedge_to_readnames[transedge].add(readname)
        transpaths.extend(_transpaths)
    return transedge_to_readnames, transpaths


def merge_transedges(transedge_to_readnames, position_wiggle):
    """
    Merge similar transedges and supportive readnames, return
        merged_transedges --- a list of tuples, where each tuple=(set_of_transedges, set_of_readnames)

    A transedge is similar to a set of transedges if and only if it is similar to any member of the set.

    Two transedges are similar if and only if
     * smaller endspoints of transedges are on the same chromosome,
     * and larger endpoints of transedges are on the same chromosome
     * and distance between smaller endpoints is less or equal to position_wiggle
     * and distance between larger endpoints is less than or equal to position_wiggle.
    """
    merged_transedges = []

    if not len(transedge_to_readnames):
        return merged_transedges

    sorted_transedges = sorted(transedge_to_readnames.keys(),
                               key=lambda transedge: transedge_cmp_key(transedge))
    def by_index(index):
        return (sorted_transedges[index], transedge_to_readnames[sorted_transedges[index]])

    def append_index_to_merged(index):
        transedge, readnames = by_index(index)
        merged_transedges.append(([transedge], readnames))

    append_index_to_merged(0) # very first tuple (set([transedge]), readnames).

    for index in range(1, len(sorted_transedges)):
        this_transedge, this_readnames = by_index(index)
        j = len(merged_transedges) - 1 # search backward to decide excess window
        while j >= 0:
            transedges, _ =  merged_transedges[j]
            if distance_between_smaller_endpoints_of_transedges(transedges[0], this_transedge) >= position_wiggle:
                break
            else:
                j -= 1

        merged = False
        # compare this_transedge against transedges at each position of
        # [len-1, len-2, ..., j) for possible merge
        for k in range(len(merged_transedges) - 1, j, -1):
            transedges, readnames = merged_transedges[k]
            # mid = mid_transedge(transedges)
            #if are_transedges_similar(this_transedge, mid, position_wiggle):
            if is_transedge_similar_to_any(this_transedge, transedges, position_wiggle):
                transedges.append(this_transedge)
                readnames.update(this_readnames)
                merged_transedges[k] = (transedges, readnames)
                merged = True
                break

        if not merged:
            append_index_to_merged(index)
    return merged_transedges


def mid_transedge(transedges):
    """
    Select a transedge which the smaller endpoint is in the middle
    to represent all similar transedges
    """
    sorted_transedges = sorted(list(transedges), key=lambda x: transedge_cmp_key(x))
    return sorted_transedges[len(sorted_transedges)/2]


def get_readcount(readnames, samples, moviename_to_sample):
    """
    readnames --- supportive read names
    samples --- biosamples
    moviename_to_sample --- movie name to sample
    """
    sample_readcount = {sample:0 for sample in samples}
    zmws = set()
    for readname in readnames:
        zmwname = readname2zmwname(readname)
        zmws.add(zmwname)
    for zmw in zmws:
        moviename = zmwname2moviename(zmw)
        sample_readcount[moviename_to_sample[moviename]] += 1
    return sample_readcount


def compute_fmts(samples, sample_readcount, sample_depth):
    """
    samples is an ordered list of samples.
    if sample_depth is None
    """
    d = {}
    for sample in samples:
        readcount = sample_readcount[sample]
        if sample_depth:
            depth = sample_depth[sample]
            readpercent = 0.0 if depth == 0 else 100 * readcount / depth
            gt = readcount_depth_percent_to_gt(readcount, depth, readpercent)
            fmt = SvFmt(gt, readcount, depth)
            d[sample] = fmt
        else:
            d[sample] = SvFmt('./.', readcount, 0)
    return SvFmts.fromDict(d)


def _from_altfmt(alt_string):
    """
    Parser ALT string and return (chr1, bp1, tbase, is_start0, is_start1).
    ...doctest:
        >>> _from_altfmt('[chr6:38963433[T')
        ('chr6', 38963433, 'T', True, True)
        >>> _from_altfmt(']chr6:38963433]T')
        ('chr6', 38963433, 'T', True, False)
        >>> _from_altfmt('T[chr6:3[')
        ('chr6', 3, 'T', False, True)
        >>> _from_altfmt('T]chr6:3]')
        ('chr6', 3, 'T', False, False)
    """
    d = {r'\[([a-zA-Z0-9_\-]+):([a-zA-Z0-9_\-]+)\[(\w)': (True, True), #'[p[t'
         r'\]([a-zA-Z0-9_\-]+):([a-zA-Z0-9_\-]+)\](\w)': (True, False), #']p]t
         r'(\w)\[([a-zA-Z0-9_\-]+):([a-zA-Z0-9_\-]+)\[': (False, True), #'t[p[
         r'(\w)\]([a-zA-Z0-9_\-]+):([a-zA-Z0-9_\-]+)\]': (False, False) #'t]p]
        }
    for pattern_string, (is_start0, is_start1) in d.iteritems():
        pattern = re.compile(pattern_string)
        if pattern.match(alt_string):
            fs = pattern.search(alt_string.strip()).groups()
            if is_start0:
                chr1, bp1, tbase = fs[0], int(fs[1]), fs[2]
            else:
                tbase, chr1, bp1 = fs[0], fs[1], int(fs[2])
            return (chr1, bp1, tbase, is_start0, is_start1)
    assert False, '{} does not conform to alt format'.format(alt_string)


def _to_altfmt(is_start0, is_start1):
    d = {(True, True): '[{p}[{t}', # t start connects p start
         (True, False): ']{p}]{t}', # t start connects p end
         (False, True): '{t}[{p}[', # t end connects p start
         (False, False): '{t}]{p}]' # t end connects p end
        }
    return d[(is_start0, is_start1)]


def get_tbase(transedge, reffa):
    transedge = to_transedge(transedge)
    if transedge.is_start0:
        s, e = transedge.bp0, transedge.bp0 + 1
    else:
        s, e = transedge.bp0 - 1, transedge.bp0
    return reffa.fetch(transedge.chr0, s, e).upper()


def to_bedrecord(transedge, tbase, fmts, sv_id):
    transedge = to_transedge(transedge)
    return BedRecord(chrom=transedge.chr0, start=transedge.bp0, end=transedge.bp0,
            sv_id=sv_id, sv_type=SvType.Bnd, sv_len=0, alt=transedge.alt(tbase),
            annotations=None, fmts=fmts)

def to_vcfrecord(transedge, tbase, fmts, sv_id):
    """
    #CHROM POS ID REF ALT QUAL FILTER INFO
    2 321681 bnd_W G G]17:198982] 6 PASS SVTYPE=BND
    2 321682 bnd_V T ]13:123456]T 6 PASS SVTYPE=BND
    13 123456 bnd_U C C[2:321682[ 6 PASS SVTYPE=BND
    13 123457 bnd_X A [17:198983[A 6 PASS SVTYPE=BND
    17 198982 bnd_Y A A]2:321681] 6 PASS SVTYPE=BND
    17 198983 bnd_Z C [13:123457[C 6 PASS SVTYPE=BND
    """
    transedge = to_transedge(transedge)
    return VcfRecord(chrom=transedge.chr0, pos=transedge.bp0,
                     ref=tbase, alt=transedge.alt(tbase), fmts=fmts, annotations=None,
                     end=transedge.bp0, sv_type=SvType.Bnd, sv_len=0, sv_id=sv_id)

def get_sorted_bam_or_none(bam_fn):
    """Return None if bam_fn is not a valid sorted bam file."""
    if bam_fn:
        assert is_bam(bam_fn)
        bam = _open_sam(bam_fn,'bam')
        if header_is_sorted_by_coordinate(bam.header.to_dict()):
            return bam
        else:
            bam.close()
    return None


def call_translocations(transpaths_fn, reffa_fn, movie_to_sample_fn,
        cfg, out_fn, bam_fn=None, output_transpaths_info=False):
    """
    Given a transpaths file, a reference fasta, a json file mapping movie to sample,
    a config file, and output bed or vcf file.
    Call all possible translocations.
    """
    if not is_bed(out_fn) and not is_vcf(out_fn):
        raise ValueError("%s must be either bed or vcf." % out_fn)
    o_bed_fn, o_vcf_fn = out_fn[:-4] + '.bed', out_fn[:-4] + '.vcf'
    bam = get_sorted_bam_or_none(bam_fn)
    min_readpercentage = cfg.min_readpercentage
    if not bam:
        log.warning('Override min_readpercentage to 0 because could not get read depth from unset bam!')
        min_readpercentage = 0
    moviename_to_sample = json_to_moviename_sample_dict(movie_to_sample_fn)
    samples = list(set(moviename_to_sample.values()))

    with open(transpaths_fn, 'r') as transstream,  Fastafile(reffa_fn) as reffa, \
            BedWriter(o_bed_fn, samples=samples) as bedwriter, \
            VcfWriter(o_vcf_fn, samples=samples) as vcfwriter:
        return _call_translocations(transstream, reffa, bam, samples, moviename_to_sample,
                cfg.min_readcount, min_readpercentage, cfg.positionwiggle,
                bedwriter, vcfwriter, output_transpaths_info)


#def pass_filter_criteria(sample_readcount, sample_depth, min_readcount, min_readpercentag):
#    """
#    #     1. total number of supporting reads across all samples is >= min_readcount
#    # AND 2. percent of supporting reads >= min_readpercentage in at least one sample
#    """
#    total_readcount = sum(sample_readcount.values())
#    def get_readpercentage(readcount, readdepth):
#        return 0.0 if readdepth == 0 else 100.0*readcount/readdepth
#    maxreadpercentage = max([ get_readpercentage(sample_readcount[sample], sample_depth[sample])
#        for sample in sample_readcount.keys()])
#    return total_readcount >= min_readcount and maxreadpercentage >= min_readpercentag


def get_or_fake_depth(bam, transedge, moviename_to_sample, sample_readcount):
    """
    Get read depth at breakpoint if bam is not None
    depth is the total number of zmws covering the region
    """
    SLOP_LENGTH = 100
    transedge = to_transedge(transedge)
    sample_depth = {sample:0 for sample in sample_readcount.keys()}
    if bam:
        ref_region = RefRegion(transedge.chr0, transedge.bp0, transedge.bp0)
        sanitized = sanitize_ref_regions([ref_region], SLOP_LENGTH, bam)[0]
        # print('transedge {} --> sanitized {}'.format(transedge, sanitized))
        zmws = set()
        for aln in bam.fetch(transedge.chr0, sanitized.start, sanitized.end):
            if not aln.is_secondary:
                zmws.add(readname2zmwname(aln.query_name))
        for zmw in zmws:
            moviename = zmwname2moviename(zmw)
            sample_depth[moviename_to_sample[moviename]] += 1
        return sample_depth
    else:
        return sample_readcount


def _call_translocations(transstream, reffa, bam, samples, moviename_to_sample,
                         min_readcount, min_readpercentag, position_wiggle,
                         bedwriter, vcfwriter, output_transpaths_info):
    transedge_to_readnames, transpaths = read_from_transpaths_sstream(transstream)
    merged_transedges = merge_transedges(transedge_to_readnames, position_wiggle)

    transedge_to_svid = {} # dict{transedge: svid}
    svid_records = [] # list of tuples, where a tuple is (svid, bedrecord, vcfrecord)

    id = 0
    for transedges, readnames in merged_transedges:
        transedge = mid_transedge(transedges)
        sample_readcount  = get_readcount(readnames, samples, moviename_to_sample)
        sample_depth = get_or_fake_depth(bam, transedge, moviename_to_sample, sample_readcount)
        id += 1
        fmts = compute_fmts(samples, sample_readcount, sample_depth)
        sv_id = 'bnd' if not len(str(id)) else 'bnd_{}'.format(id)
        tbase = get_tbase(transedge, reffa)
        bedrecord = to_bedrecord(transedge, tbase, fmts, sv_id)
        vcfrecord = to_vcfrecord(transedge, tbase, fmts, sv_id)
        svid_records.append( (sv_id, bedrecord, vcfrecord) ) # save bed/vcf records

        for transedge in transedges: # associate all transedges with this svid
            transedge_to_svid[transedge] = sv_id

    yielder = yield_records_with_transpaths_info if output_transpaths_info else yield_records_as_is
    for bedrecord, vcfrecord in yielder(svid_records=svid_records,
            transpaths=transpaths, transedge_to_svid=transedge_to_svid):
        if not pass_filter_criteria(bedrecord, min_readcount, min_readpercentag):
            continue
        bedwriter.writeRecord(bedrecord)
        vcfwriter.writeRecord(vcfrecord)

def pass_filter_criteria(record, min_readcount, min_readpercentage):
    readcount = sum([fmt.ad for fmt in record.fmts.fmts])
    maxreadpercentage = max([fmt.ad * 100  / fmt.dp if fmt.dp > 0 else 0.0
                             for fmt in record.fmts.fmts])
    return readcount >= min_readcount and maxreadpercentage >= min_readpercentage

def yield_records_as_is(svid_records, transpaths, transedge_to_svid):
    """yield (bedrecord, vcfrecord) as is."""
    for svid, bedrecord, vcfrecord in svid_records:
        yield (bedrecord, vcfrecord)

def yield_records_with_transpaths_info(svid_records, transpaths, transedge_to_svid):
    """
    add transpaths in to bedrecord and vcfrecord and
    yield (bedrecord, vcfrecord)
    svid_records --- a list of tuples, where each tuple is (pbsv, bedrecord, vcfrecord)
    transpaths --- a list of transpath objects where each transpath
    contains a sorted list of transedges., e.g.,
    [ [[e0, e1, e2], [e3, e4]], [[], ...], ...]
    transedge_to_svid --- a dict map transedge to svid, e.g., dict{transedge: svid}
    """
    f = svid_to_svids_list_func(transpaths=transpaths, transedge_to_svid=transedge_to_svid)

    # update bed/vcfrecords with transpaths info
    for svid, bedrecord, vcfrecord in svid_records:
        # get associated transpaths with this sv
        # uids = svid_to_uids[svid] # ids of associated transpaths in unique_transpaths
        # get a list of svids, where each svids represent a transpath associated with this
        # svids_list = [unique_transpaths[uid] for uid in uids]
        svids_list = f(svid) # f is a lambda svid: svids_list
        # update records with associated transpaths
        assert len(svids_list), 'Could not find svid {} in transpath' % (svid)
        bedrecord.transpaths = ['({})'.format(','.join(svids)) for svids in svids_list]
        vcfrecord.transpaths = ['({})'.format(','.join(svids)) for svids in svids_list]
        yield (bedrecord, vcfrecord)


def svid_to_svids_list_func(transpaths, transedge_to_svid):
    """
    return a lambda svid: svids_list

    transpaths --- a list of transpath objects where each transpath
    contains a sorted list of transedges., e.g.,
    [ [e0, e1, e2], [e3, e4], ..]
    transedge_to_svid --- a dict map transedge to svid, e.g.,
    dict{e0: 0, e1:1, e2:2, e3:3, e4:4}
    """
    # convert each transpath to svids, and transpaths as a list of svids
    transpaths_as_svids_list = [transpath_as_svids(t, transedge_to_svid)
            for t in transpaths]
    unique_transpaths = remove_redundant_transpaths(transpaths_as_svids_list)
    # unique_transpaths: [ [svid, svid, svid], [svid, svid] ], a list of svids.
    svid_to_uids = defaultdict(list) # dict(svid, [index_of_unique_transpath, ...])
    for idx, unique_transpath in enumerate(unique_transpaths):
        for svid in unique_transpath:
            svid_to_uids[svid].append(idx)
    return lambda x: [unique_transpaths[uid] for uid in svid_to_uids[x]]


def transpath_as_svids(transpath, transedge_to_svid):
    """
    Each transpath is originally represented as a list of ordered transedges.
    Each transedge maps to an unique svid.
    Represent each transpath as a list of ordered svids.
    ... doctest:
        >>> transpath_as_svids((0, 1, 2), {0: 7, 1:8, 2:9})
        [7, 8, 9]
    """
    return [transedge_to_svid[transedge] for transedge in transpath]


def is_subset(ids, uids):
    """Return True if ordered list ids is a subset of ordered list uids,
       or ids[::-1] is a subset of uids.
    ...doctest:
        >>> is_subset([1], [1,2]) and is_subset([1], [2,1])
        True
        >>> is_subset([1,2], [3,4,5]) or is_subset([1,2,3,4], [3,1,2,4]) or is_subset([1], [3,4,5])
        False
        >>> is_subset([1,2], [1,2,3]) and is_subset([1,2], [3,1,2]) and  is_subset([1,2], [3,2,1])
        True
        >>> is_subset([1,2,3], [3,2,1,4]) and is_subset([1,2,3], [4,3,2,1])
        True
    """
    return _is_subset(ids, uids) or _is_subset(ids[::-1], uids)

def _is_subset(ids, uids):
    """Return True if ordered list ids is a subset of ordered list uids.
    ...doctest:
        >>> _is_subset([1,2], [2,1]) or _is_subset([1,2,3,4], [3,1,2,4]) or _is_subset([1], [3,4,5])
        False
        >>> _is_subset([1,2], [1,2,3]) and _is_subset([1,2], [3,1,2])
        True
        >>> is_subset([1,2,3], [3,2,1,4]) and is_subset([1,2,3], [4,3,2,1])
        True
        >>> is_subset([1,2,3], [2,3,1])
        False
    """
    if len(ids) > len(uids):
        return False
    if len(ids) == 1:
        return ids[0] in uids
    id0 = ids[0]
    try:
        index = uids.index(id0)
        return len(ids) <= len(uids)-index and ids == uids[index:index+len(ids)]
    except ValueError:
        return False

def is_superset(ids, uids):
    return is_subset(uids, ids)

def remove_redundant_transpaths(transpaths_as_svids_list):
    """
    transpaths_as_svids_list --- a list of svids, where each svids
    contain multiple svids to represent a transpath
    Just remove redundant, DON'T chain multiple transpaths,
    e.g., DON'T chain (e0, e1, e2) with (e1, e2, e3) to (e0, e1, e2, e3).
    """
    unique_transpaths = []
    for svids in transpaths_as_svids_list:
        append = True # append svids to unique_transpaths or not
        for idx, usvids in enumerate(unique_transpaths):
            if is_subset(svids, usvids): # svids in usvids, skip
                append = False
                break
            elif is_superset(svids, usvids): # usvids in svids, replace usvids by svids
                unique_transpaths[idx] = svids
                append = False
                break
        if append:
            unique_transpaths.append(svids)
    return unique_transpaths


def make_transpaths(bam_reader, write_translocation_f, cfg):
    """Parser input alignment bam and output transpaths file."""
    querynames = set()  # query names seen thus far
    readsegs = []      # list of aligned segments for the current read
    # The input BAM must be grouped by query name, which is validated as the
    # file is read.
    for scur in bam_reader:
        # group segments from the same read; chain the segments for the
        # previous read when a new read is found
        if len(readsegs) and readsegs[0].query_name != scur.query_name:
            # new read; confirm it has not been seen before
            assert scur.query_name not in querynames, \
                "segments for read %s not grouped" % (scur.query_name)
            # tag inversions
            has_inversion = tag_inversions(readsegs, inversion_poswiggle=cfg.inversion_poswiggle)
            if not has_inversion:
                tag_translocations(readsegs, translocation_poswiggle=500, out_handler_f=write_translocation_f)
            readsegs = []  # free the segments for the previous read
        if not scur.is_secondary: # no use secondary
            querynames.add(scur.query_name)
            readsegs.append(scur)
