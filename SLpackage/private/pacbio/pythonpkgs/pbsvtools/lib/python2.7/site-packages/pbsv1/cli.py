"""
Define command line entry for tool `pbsv1`, including
    pbsv1 align
    pbsv1 call
    pbsv1 run
    pbsv1 generate-config
    pbsv1 trf

Define `pbsv1util`, utils for pbsv1, including
    pbsv1util ngmlr
    pbsv1util markduplicates
    pbsv1util chain
    pbsv1util x2fasta
    pbsv1util prepare-reference
"""
from __future__ import absolute_import

import os
import os.path as op
import sys
import logging
import json
from .__init__ import get_version
from .__utils import (get_default_argparser, setup_log, main_runner,
                      compose, subparser_builder, validate_file, args_executer)
from .markdup import (markdup_desc, markdup_epilog, markdup, make_readgroups)
from .chain import chain_all
from .call import svcall
from .translocation import call_translocations, make_transpaths
from .ngmlrmap import ngmlrmap
from .prepare_reference import prepare_reference
from .minimap2_map import minimap2_map
from .run import svalign
from .io.linefile import x2fasta
from .io.bamstream import BamStream
from . import config
from .independent.common import to_ref_regions
from .independent.utils import is_json, readname2moviename, transpaths_of_bam
from . import Constants as C
from .utils import modify_alignedseg_rg_tag
from .sort_sv import sort_sv
from .set_readgroup import modify_readgroups_of_bam
from .samples import make_samples
from .io.bamstream import (get_movienames2readgroups_from_header, json_to_readgroup_sample_dict,
        get_bam_header, sanitize_ref_regions)
from .filter_sv import filter_sv
from .trf import find_tandemrepeats
from .trf import epilog as trf_epilog
from .trf import desc as trf_desc


log = logging.getLogger()
slog = logging.getLogger('status.' + __file__)


def _mkdir(path):
    """Create a directory if it does not pre-exist,
    otherwise, pass.
    return path
    """
    if not op.isdir(path):
        try:
            os.makedirs(path)
        except OSError as e:
            # "File exists error" can happen when python
            # fails to syncronize with NFS or multiple
            # processes are trying to make the same dir.
            if e.errno == 17:
                pass
            else:
                raise
    return path


def _add_output_dir_option(p):
    p.add_argument('-o', '--output-dir', default=op.join(os.getcwd(), "output"),
                   type=_mkdir,
                   help="Path to job output directory. Directory will be created if it does not exist.")
    return p


def _add_reads_bam_parser_options(p):
    p.add_argument('reads_bam', type=validate_file,
                   help="Path to PacBio subreads bam or SubreadSet file.")
    return p


def __add_ngmlr_bam_parser_options(p, type_f):
    """Add ngmlr bam as either input or output"""
    p.add_argument('ngmlr_bam', type=type_f,
                   help="Path to ngm_lr output alignments bam file.")
    return p


def _add_i_ngmlr_bam_parser_options(p):
    """Add ngmlr bam as input of another tool"""
    return __add_ngmlr_bam_parser_options(p, validate_file)


def _add_o_ngmlr_bam_parser_options(p):
    """Add output bam for ngmlr alignments"""
    return __add_ngmlr_bam_parser_options(p, str)

def _add_o_minimap2_bam_parser_options(p):
    p.add_argument('minimap2_bam', type=str,
                   help='Path to minimap2 output alignments bam file.')
    return p

def _add_reffa_parser_options(p):
    p.add_argument('ref_fn', type=validate_file,
                   help="reference genome in FASTA or ReferenceSet (.fai index required)")
    return p


def _add_reference_region_option(p):
    helpstr = ("Only call structural variants within reference regions specified either " +
              "in a .bed file, or an .interval file, or a semicolon-delimited string, " +
              "allowing for position wiggle. " +
              "A .bed file must end with '.bed' and each line represents a reference region " +
              "REFERENCE[\\tSTARTPOS[\\tENDPOS]], e.g., chr\\t0\\t100. " +
              "An .interval file must end with '.interval' and each line represents a " +
              "reference region REFERENCE[:STARTPOS[-ENDPOS]], e.g., chr1:1-10,000. " +
              "A semicolon delimited string of reference regions, e.g., chr1:1-10,000;chr3:200.")
    p.add_argument('--reference_regions', default='', type=to_ref_regions, help=helpstr)
    return p


def _add_i_align_bam_parser_options(p):
    """Add sorted chain bam as input of `pbsv1 call`"""
    p.add_argument("align_bam", type=validate_file,
                   help="Input BAM/SAM/FOFN/AlignmentSet file, alignments in which are sorted by coordinate")
    return p


def _add_o_align_bam_parser_options(p):
    """Add bam as output of sorted chain"""
    p.add_argument("align_bam", type=str,
                   help="Output BAM/SAM alignments sorted by coordinate")
    return p


def _add_o_bed_parser_options(p):
    """Add bed output to parser"""
    p.add_argument("out_bed", help="structural variant calls")
    return p


def _add_cfg_parser_option(p):
    """Add config file, convert config file path to config obj."""
    p.add_argument("--cfg_fn", metavar="sv.cfg", dest="cfg",
                   type=config.SVConfig, default=config.SVConfig(), help="pbsv config file")
    return p


def __add_makedup_bam_parser_options(p, type_f):
    p.add_argument('markdup_bam', type=type_f,
                   help="Path to pbsv markduplicates output alignments bam file.")
    return p


def _add_o_makedup_bam_parser_options(p):
    """Add a bam as output of `pbsv1 markduplicates`"""
    return __add_makedup_bam_parser_options(p, str)


def _add_movienames2samples_parser_options(p):
    """Add an optional argument, a json file which contains a dict {moviename: sample}"""
    helpstr = """Path to a json file containing a {moviename: sample} dict.
Since subreads BAM header does not contain SM tag in RG group, to link read groups with samples,
we assume that each movie is associated with a read group, and use --movienames2samples_json
to link movies to samples, and therefore link read groups (and all reads in read groups) with samples.
Sample must not be empty and characters must be in [0-9a-zA-Z\-\_]."""
    p.add_argument('--movienames2samples_json', type=validate_file, default=None, help=helpstr)
    return p


def _add_i_x2fasta_parser_options(p):
    """Add input for `pbsv1util x2fasta`"""
    # positional arguments
    p.add_argument("input_files", metavar="input_files", nargs="*", type=str, default=["stdin"],
                   help="List of files to concatenate. (default: %(default)s)")
    return p


def _add_o_x2fasta_parser_options(p):
    """Add output for `pbsv1util x2fasta`"""
    # optional arguments
    p.add_argument("-o", dest="output_file", metavar="output_file", type=str, default="stdout",
                   help="File to write concatenated results. (default: %(default)s)")
    return p


def _add_o_chain_bam_parser_options(p):
    """Add chain_bam as output of `pbsv1util chain`"""
    p.add_argument('out_chain_bam', type=str,
                   help="Path to `pbsv1 chain` output alignments bam file.")
    return p


def _add_i_chain_bam_parser_options(p):
    """Add input of `pbsv1util chain`"""
    p.add_argument("in_chain_bam", type=validate_file, default="stdout",
                   help="input BAM/SAM grouped by \"queryname\", e.g., `pbsv1 markdup` output")
    return p


def _add_template_bam_parser_options(p):
    helpstr = 'Template BAM/SAM file providing `RG` read groups for output bam, e.g., subreads.bam.'
    p.add_argument("--template_bam", type=validate_file, help=helpstr)
    return p


def add_markdup_parser_options(p):
    """Add `pvsvutil markduplcates` parser options"""
    fs = [
        _add_o_makedup_bam_parser_options,
        _add_i_ngmlr_bam_parser_options,
        _add_movienames2samples_parser_options,
        _add_template_bam_parser_options,
        _add_cfg_parser_option
    ]
    f = compose(*fs)
    return f(p)


def add_x2fasta_parser_options(p):
    """Add `pbsv1util x2fasta` parser options"""
    fs = [
        _add_i_x2fasta_parser_options,
        _add_o_x2fasta_parser_options
    ]
    f = compose(*fs)
    return f(p)

def add_prepare_reference_parser_options(p):
    """Add `pbsv1util prepare-reference` parser options"""
    p.add_argument("in_ref", metavar="input_reference_fasta_or_xml", type=validate_file,
                   help="Input reference fasta or reference set xml")
    p.add_argument("out_ref", metavar="output_reference_fasta_or_xml", type=str,
                   help="Output reference fasta or reference set xml, file format determined by file extension")
    return p

def add_set_readgroup_parser_options(p):
    """Add `pbsv1util set-readgroup` parser options"""
    def _add_i(p):
        p.add_argument("in_fn", metavar="input_bam_or_sam_or_xml", type=validate_file,
                       help="Input reads or alignments in bam, sam, SubreadSet")
        return p
    def _add_o(p):
        p.add_argument("out_fn", metavar="output_bam_or_sam", type=str,
                       help="Output reads or alignments in bam or sam file, file format determined by file extension.")
        return p
    fs = [
        _add_o, _add_i,
        _add_movienames2samples_parser_options,
        _add_template_bam_parser_options,
    ]
    f = compose(*fs)
    return f(p)


def add_make_samples_parser_options(p):
    """Add `pbsv1util make-samples` parser options"""
    def _add_i_subreadset(p):
        p.add_argument("in_subreadset_xml", type=validate_file, help="Input SubreadSet xml.")
        return p
    def _add_o_m2s_json(p):
        p.add_argument("samples2sanitizedsamples_json", type=str,
                       help="Output json containing a list of (sample, sanitized_sample) tuples.")
        return p
    def _add_o_s2s_json(p):
        p.add_argument("movienames2samples_json", type=str,
                       help="Output json containing a list of (movie, sanitized_sample) tuples.")
        return p
    fs = [_add_o_s2s_json, _add_o_m2s_json, _add_i_subreadset]
    f = compose(*fs)
    return f(p)


def add_sort_sv_parser_options(p):
    def _add_i_sv_fn(p):
        p.add_argument('in_sv', type=validate_file, help="Input structural variants in VCF|BED.")
        return p
    def _add_o_sv_fn(p):
        p.add_argument('o_sv', type=str, help="Output sorted structural variants in VCF|BED.")
        return p
    fs = [_add_o_sv_fn, _add_i_align_bam_parser_options, _add_i_sv_fn]
    f = compose(*fs)
    return f(p)

def add_make_trans_parser_options(p):
    """Add `pbsv1utl make-trans` parser """
    def _add_o_transpaths_parser_option(p):
        p.add_argument("o_transpaths_fn", type=str, help="Output transpaths file")
        return p
    def _add_i_aligned_bam_parser_option(p):
        p.add_argument("i_align_bam", type=validate_file, help="Input minimap2 alignment bam")
        return p
    fs = [_add_o_transpaths_parser_option, _add_i_aligned_bam_parser_option, _add_cfg_parser_option]
    f = compose(*fs)
    return f(p)

def add_call_trans_parser_options(p):
    """Add `pbsv1util call-trans` parser options"""
    def _add_i_s2s_json(p):
        p.add_argument("--movie-to-sample-json", type=validate_file,
                       help="Input json containing a list of (movie, sanitized_sample) tuples.")
        return p
    def _add_i_transpaths_parser_option(p):
        p.add_argument("transpaths_fn", type=validate_file,
                       help="Input transpaths file.")
        return p
    def _add_optional_sorted_indexed_bam(p):
        p.add_argument("--sorted-indexed-aligned-bam", default=None,
                       help="Optional sorted indexed aligned bam providing read depth near translocations.")
        return p
    def _add_optional_transpaths_info(p):
        p.add_argument("--transinfo", action='store_true',
                       help="Output translocation paths info in BED/VCF")
        return p

    fs = [
        _add_o_bed_parser_options,
        _add_i_transpaths_parser_option,
        _add_reffa_parser_options,
        _add_cfg_parser_option,
        _add_optional_sorted_indexed_bam,
        _add_optional_transpaths_info,
        _add_i_s2s_json
    ]
    f = compose(*fs)
    return f(p)

def add_filter_sv_parser_options(p):
    def _add_minreadcount_parser(p):
        p.add_argument('-c', '--min-readcount', default=0, type=int,
                       help="Minimum Read Count over all samples")
        return p
    def _add_minreadpercentage_parser(p):
        p.add_argument('-p', '--min-readpercentage', default=0, type=float,
                       help="Minimum Read Percentage in at least one sample")
        return p
    def _add_minreaddepth_parser(p):
        p.add_argument('-d', '--min-readdepth', default=0, type=int,
                       help="Minimum Read Depth, including supportive and non-supportive reads")
        return p
    def _add_i_sv_fn(p):
        p.add_argument('in_sv', type=validate_file, help="Input structural variants in VCF|BED.")
        return p
    def _add_o_sv_fn(p):
        p.add_argument('o_sv', type=str, help="Output filtered structural variants in VCF|BED.")
        return p
    fs = [
        _add_minreaddepth_parser,
        _add_minreadpercentage_parser,
        _add_minreadcount_parser,
        _add_o_sv_fn,
        _add_i_sv_fn
            ]
    f = compose(*fs)
    return f(p)

def add_chain_parser_options(p):
    """Add `pvsvutil chain` parser options"""
    fs = [
        _add_o_chain_bam_parser_options,
        _add_i_chain_bam_parser_options,
        _add_cfg_parser_option
    ]
    f = compose(*fs)
    return f(p)


def add_ngmlrmap_parser_options(p):
    """Add `pvsvutil ngmlr` parser options"""
    fs = [
        _add_o_ngmlr_bam_parser_options,
        _add_reads_bam_parser_options,
        _add_reffa_parser_options,
        _add_cfg_parser_option
    ]
    f = compose(*fs)
    return f(p)


def add_minimap2_parser_options(p):
    fs = [
        _add_o_minimap2_bam_parser_options,
        _add_reads_bam_parser_options,
        _add_reffa_parser_options,
        _add_cfg_parser_option
    ]
    f = compose(*fs)
    return f(p)


def add_align_parser_options(p):
    """Add `pbsv1 align` parser options"""
    fs = [
        _add_o_align_bam_parser_options,
        _add_reads_bam_parser_options,
        _add_reffa_parser_options,
        _add_movienames2samples_parser_options,
        _add_cfg_parser_option
    ]
    f = compose(*fs)
    return f(p)


def add_call_parser_options(p):
    """Add `pvsv call` parser options"""
    fs = [
        _add_o_bed_parser_options,
        _add_i_align_bam_parser_options,
        _add_reffa_parser_options,
        _add_reference_region_option,
        _add_cfg_parser_option
    ]
    f = compose(*fs)
    return f(p)


def add_run_parser_options(p):
    """Add `pbsv1 run` parser options for end-to-end pbsv1 pipeline"""
    fs = [
        _add_o_bed_parser_options,
        _add_reads_bam_parser_options,
        _add_reffa_parser_options,
        _add_cfg_parser_option
    ]
    f = compose(*fs)
    return f(p)


def add_gencfg_parser_options(p):
    """Add `pbsv1 genenrate-config` parser options"""
    p.add_argument('-o', '--cfg_fn', metavar="sv.cfg", dest="cfg_fn",
                   type=str, default=None, help="Pbsv1 config file.")
    return p


def add_trf_parser_options(p):
    p.add_argument("reffa", metavar="ref.fa")
    p.add_argument("outbed", metavar="out.bed")
    p.add_argument("--chrom", metavar="chr", help="Limit analysis to this chromosome")
    p.add_argument("--merge", action="store_true", help="Merge overlapping tandem repeats")
    def f(param, metavar):
        p.add_argument("--{}".format(param.name), metavar=metavar, type=param.type, help=param.desc, default=param.val)
    f(C.TRF_K, "N")
    f(C.TRF_MAXPERIOD, "N")
    f(C.TRF_MINCOPIES, "F")
    f(C.TRF_MINLENGTH, "N")
    f(C.TRF_MINMATCHBP, "N")
    f(C.TRF_MINMATCHFRACTION, "F")
    return p


def _args_run_align(args):
    """Align reads to reference, mark dup, chain, sort"""
    log.info("Running `pbsv1 align`")
    svalign(ref_fn=args.ref_fn, in_fn=args.reads_bam,
            out_bam=args.align_bam, cfg=args.cfg, tmp_dir=None,
            movienames2samples_json=args.movienames2samples_json)


def _args_run_call(args):
    """Run pbsv1 call"""
    log.info("Running `pbsv1 call`")
    cfg = args.cfg
    ref_regions = sanitize_ref_regions(ref_regions=args.reference_regions,
                                       slop_size=cfg.positionwiggle, align_bam=args.align_bam)
    svcall(bamin=args.align_bam, reffa=args.ref_fn, bedout=args.out_bed, cfg=cfg, ref_regions=ref_regions)
    return 0

def _args_run_make_trans(args):
    """Run pbsv1util make-trans"""
    log.info("Running `pbsv1util make-trans`")
    log.info("Arguments: {!r}".format(args))
    log.info("make_transpaths(%r, %r)", args.i_align_bam, args.o_transpaths_fn)
    with BamStream(args.i_align_bam, None, False) as reader, \
            open(args.o_transpaths_fn, 'w') as writer:
        def f(s):
            writer.write(s+'\n')
        make_transpaths(bam_reader=reader, write_translocation_f=f, cfg=args.cfg)
    return 0

def _args_run_call_trans(args):
    """Run pbsv1util call-trans"""
    log.info("Running `pbsv1util call-trans`")
    call_translocations(transpaths_fn=args.transpaths_fn,
            reffa_fn=args.ref_fn, movie_to_sample_fn=args.movie_to_sample_json,
            cfg=args.cfg, out_fn=args.out_bed,
            bam_fn=args.sorted_indexed_aligned_bam,
            output_transpaths_info=args.transinfo)
    return 0

def _args_run_filter_sv(args):
    log.info("Running `pbsv1util filter-sv`")
    filter_sv(args.in_sv, args.o_sv, min_readcount=args.min_readcount,
              min_readpercentage=args.min_readpercentage,
              min_readdepth=args.min_readdepth)
    return 0


def _args_gencfg_run(args):
    log.info("Running `pbsv1 generate-config`")
    if args.cfg_fn:
        writer = open(args.cfg_fn, 'w')
    else:
        writer = sys.stdout
    config.svconfig_write(config.SVConfig(), writer)
    return 0


def _args_trf_run(args):
    """Find tandem repeats from pbsv1 trf"""
    find_tandemrepeats(reffa=args.reffa, out_bed=args.outbed, chrom=args.chrom,
                       merge=args.merge, k=args.k, maxPeriod=args.maxPeriod,
                       minCopies=args.minCopies, minLength=args.minLength,
                       minMatchBp=args.minMatchBp, minMatchFraction=args.minMatchFraction)
    return 0


def _args_run_ngmlrmap(args):
    """Run pbsv1util ngmlr"""
    log.info("Running `pbsv1util ngmlr`")
    ngmlrmap(in_fn=args.reads_bam, ref_fn=args.ref_fn,
             out_bam=args.ngmlr_bam, nproc=args.cfg.nproc)
    return 0


def _args_run_minimap2(args):
    """Run pbsv1util minimap2"""
    log.info("Running `pbsv1util minimap2`")
    minimap2_map(in_fn=args.reads_bam, ref_fn=args.ref_fn,
                 out_bam=args.minimap2_bam, nproc=args.cfg.nproc)
    return 0


def _args_run_chain(args):
    """Run pbsv1util chain"""
    log.info("Running `pbsv1util chain`")
    writer = open(transpaths_of_bam(args.out_chain_bam), 'w')
    def f(s):
        writer.write(s+'\n')
    chain_all(bamin=args.in_chain_bam, bamout=args.out_chain_bam, cfg=args.cfg, write_translocation_f=f)
    writer.close()
    return 0


def _args_run_markdup(args):
    """Run pbsv1util markduplicates"""
    log.info("Running `pbsv1util markduplicates`")
    cfg = args.cfg

    if not args.template_bam:
        raise ValueError("Must specify --template_bam e.g., subreads.bam, from which RG groups will be exported")

    template_header = get_bam_header(args.template_bam)
    readgroups = make_readgroups(template_header, args.movienames2samples_json)
    movienames2readgroups = get_movienames2readgroups_from_header(template_header) # {moviename: readgroup}

    def modify_alignedseg_rg_tag_f(record):
        """Modify the RG tag of an alignment record."""
        moviename = readname2moviename(record.query_name)
        if not moviename in movienames2readgroups:
            raise ValueError("Could not find read group ID of movie {moviename} from {template_bam}.".
                             format(moviename=moviename, template_bam=args.template_bam))
        return modify_alignedseg_rg_tag(record, movienames2readgroups[moviename])

    markdup(bamin=args.ngmlr_bam, bamout=args.markdup_bam,
            tolerance=cfg.tolerance, onesided=cfg.onesided, samezmw=cfg.samezmw,
            readgroups=readgroups, modify_alignedseg_f=modify_alignedseg_rg_tag_f)
    return 0


def _args_run_x2fasta(args):
    """Run pbsv1util x2fasta"""
    log.info("Running `pbsv1util x2fasta`")
    x2fasta(input_files=args.input_files, output_file=args.output_file)
    return 0

def _args_run_prepare_reference(args):
    """Run pbsv1util prepare-reference"""
    log.info("Running `pbsv1util prepare-reference`")
    prepare_reference(in_ref=args.in_ref, out_ref=args.out_ref, aligner=args.cfg.subreads_aligner)
    return 0

def _args_run_set_readgroup(args):
    log.info("Running `pbsv1util set-readgroup`")

    if not args.template_bam:
        raise ValueError("Must specify --template_bam e.g., subreads.bam, from which RG groups will be exported")
    readgroups = make_readgroups(get_bam_header(args.template_bam), args.movienames2samples_json)
    modify_readgroups_of_bam(args.in_fn, args.out_fn, args.movienames2samples_json, readgroups)
    return 0

def _args_run_make_samples(args):
    log.info("Running `pbsv1util make-samples`")
    make_samples(ds_fn=args.in_subreadset_xml, movie_sanitized_sample_fn=args.movienames2samples_json,
                 sample_sanitized_sample_fn=args.samples2sanitizedsamples_json)
    return 0

def _args_run_sort_sv(args):
    log.info("Running `pbsv1util sort-sv`")
    sort_sv(args.in_sv, args.align_bam, args.o_sv)
    return 0

def pbsv_get_parser():
    """Get parser for pbsv1 subcommands"""
    desc = "PacBio Structural Variants Detection Tool Suite"
    p = get_default_argparser(version=get_version(), description=desc)

    sp = p.add_subparsers(help='commands')

    def builder(subparser_id, description, options_func, exe_func, epilog=None):
        """subparser builder"""
        subparser_builder(sp, subparser_id, description,
                          options_func, exe_func, epilog)

    # `pbsv1 align`, aligns reads to reference, mark dup, chain, sort and etc.
    align_desc = "Align reads in a BAM file to reference genome, " + \
               "chain alignments, mark duplicates and sort."
    builder('align', align_desc, add_align_parser_options, _args_run_align)

    # `pbsv1 call`, call structural variants
    call_desc = "Call structural variants from long read alignments"
    builder('call', call_desc, add_call_parser_options, _args_run_call)

    gencfg_desc = "Generate a config file for pbsv1 tool suite."
    builder('generate-config', gencfg_desc,
            add_gencfg_parser_options, _args_gencfg_run)

    builder('trf', trf_desc, add_trf_parser_options, _args_trf_run, trf_epilog)

    return p


def pbsvutil_get_parser():
    """Get parser for pbsv1util subcommands"""

    desc = "Utils for PacBio Structural Variants Tool"
    p = get_default_argparser(version=get_version(), description=desc)

    sp = p.add_subparsers(help='commands')

    def builder(subparser_id, description, options_func, exe_func, epilog=None):
        """subparser builder"""
        subparser_builder(sp, subparser_id, description,
                          options_func, exe_func, epilog)
    # `pbsv1util ngmlr`
    map_desc = "Use ngmlr to map reads to reference genome and make alignments"
    builder('ngmlr', map_desc, add_ngmlrmap_parser_options, _args_run_ngmlrmap)

    # `pbsv1util minimap2`
    map_desc = "Use minimap2 to map reads to reference genome and make alignments"
    builder('minimap2', map_desc, add_minimap2_parser_options, _args_run_minimap2)

    # `pbsv1util ngmlr`, mark or remove duplicates
    builder('markduplicates', markdup_desc, add_markdup_parser_options,
            _args_run_markdup, markdup_epilog)

    # `pbsv1util chain`, chain alignments
    chain_desc = "Merge/chain colinear BAM alignments."
    builder('chain', chain_desc, add_chain_parser_options, _args_run_chain)

    x2fasta_desc = "Based on suffix (.gz, .bz2, .bgz) will cat compressed files properly"
    builder('x2fasta', x2fasta_desc, add_x2fasta_parser_options, _args_run_x2fasta)

    prepare_reference_desc = "Prepare reference index."
    builder('prepare-reference', prepare_reference_desc, add_prepare_reference_parser_options, _args_run_prepare_reference)

    set_rg_tag_desc = "Modify input alignments in SAM/BAM file and assign `RG` tag to all alignments."
    builder('set-readgroup', set_rg_tag_desc, add_set_readgroup_parser_options, _args_run_set_readgroup)

    make_samples_desc = "Get {movie: sanitized_sample} and {sample: sanitized_sample} from dataset and write to json."
    builder('make-samples', make_samples_desc, add_make_samples_parser_options, _args_run_make_samples)

    sort_sv_desc = 'Sort structural variants in chromosome order as listed in header of the BAM file'
    builder('sort-sv', sort_sv_desc, add_sort_sv_parser_options, _args_run_sort_sv)

    make_trans_desc = 'Call translocation'
    builder('make-trans', make_trans_desc, add_make_trans_parser_options, _args_run_make_trans)

    call_trans_desc = 'Call translocations'
    builder('call-trans', call_trans_desc, add_call_trans_parser_options, _args_run_call_trans)

    filter_sv_desc = 'Filter structural variants'
    builder('filter-sv', filter_sv_desc, add_filter_sv_parser_options, _args_run_filter_sv)
    return p

def pbsv_main(argv=None):
    """pbsv1 Main function, entry for command line tool `pbsv1`"""

    argv_ = sys.argv if argv is None else argv
    parser = pbsv_get_parser()

    return main_runner(argv_[1:], parser, args_executer, setup_log, log)


def pbsvutil_main(argv=None):
    """pbsv1util main function, entry for command line tool `pbsv1uti1`"""

    argv_ = sys.argv if argv is None else argv
    parser = pbsvutil_get_parser()

    return main_runner(argv_[1:], parser, args_executer, setup_log, log)
