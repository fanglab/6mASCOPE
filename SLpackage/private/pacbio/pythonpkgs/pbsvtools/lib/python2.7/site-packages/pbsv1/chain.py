"""Merge colinear BAM alignments.

Aligners like `bwa` and `ngmlr` produce local alignments that represent a region of
high similarity between a query and reference sequence. A run of dissimilarity or a
large gap causes a local alignment to end, and two regions of similarity that span
dissimilarity are represented as two separate local alignments.

For visualization and variant calling, it is often desirable to extend alignments
through such gaps.  Chaining joins colinear local alignments into single chained
alignments.

For example, consider two alignments "X" and "Y" shown in a dotplot. The alignments
are "colinear" as both are in the same direction and Y starts and ends after X in
both reference and read coordinates.  So, X and Y can be chained into a single
alignment Z with a large gap.


    +------------------------+                   +------------------------+
    | X                      |                   | Z                      |
    |  X                     |                   |  Z                     |
    |   X                    |                   |   Z                    |
    |    X                   |                   |    Z                   |
    |     X          Y       |                   |     Z                  |
    |      X          Y      |   --bamChain-->   |      Z                 |
    |       X          Y     |                   |       ZZZZZZZZZZZZ     |
    |                   Y    |                   |                   Z    |
    |                    Y   |                   |                    Z   |
    |                     Y  |                   |                     Z  |
    |                      Y |                   |                      Z |
    +------------------------+                   +------------------------+

Support detection of inversions.
"""
from __future__ import absolute_import

import logging
import pysam
from collections import defaultdict, deque
from .libs import AlignmentFile, AlignedSegment
from .independent.utils import autofmt, revcomp, is_stdin
from .io.bamstream import BamStream
from .config import get_config
from .aln.cigar import (MATCH, INS, DEL, SOFT_CLIP, HARD_CLIP, QUERYOPS, REFOPS)
from .inversion import (tag_inversions, are_both_inv_or_flank_alns)
from .translocation import (tag_translocations)

log = logging.getLogger()


def stripclipping(cigartuplesdeque):
    """Remove clipping operations from a cigartuples deque.

    Return (hardclipleft, softclipleft, hardclipright, softclipright)"""
    hcleft, scleft, hcright, scright = 0, 0, 0, 0
    if cigartuplesdeque[0][0] == HARD_CLIP:
        dummy_op, hcleft = cigartuplesdeque.popleft()
    if cigartuplesdeque[0][0] == SOFT_CLIP:
        dummy_op, scleft = cigartuplesdeque.popleft()
    if cigartuplesdeque[-1][0] == HARD_CLIP:
        dummy_op, hcright = cigartuplesdeque.pop()
    if cigartuplesdeque[-1][0] == SOFT_CLIP:
        dummy_op, scright = cigartuplesdeque.pop()
    return hcleft, scleft, hcright, scright


def revqual(qual):
    """Reverse a pysam quality array."""
    # pysam does not expose a utility to reverse a quality array,
    # but it does expose quality array to string and vice versa.
    # So, convert the array to a string, reverse the string, and
    # then convert back to an array.
    qualstring = pysam.qualities_to_qualitystring(qual) # pylint: disable=no-member
    return pysam.qualitystring_to_array(''.join(reversed(qualstring))) # pylint: disable=no-member


def chain(readsegs, min_mapq, max_gap, skip_chain_alns_f):
    """Chain colinear aligned segments for a single read.

    Colinear segments are separate local alignments of a read to a
    chromosome in the same order and orientation.
    skip_chain_alns_f --- skip_chain_alns_f(a0, a1) returns True to skip chain a0 and a1
    """

    query_name = readsegs[0].query_name
    refidtoname = dict()  # reference ID to name map
    for s in readsegs:
        if not s.is_unmapped:
            refidtoname[s.reference_id] = s.reference_name

    # Identify the primary segment (or any another segment with no hard clipping).
    # It should be sufficient to identify the primary segment, as that segment is
    # required by the SAM specification to exist for mapped and unmapped reads and
    # not to have any hard clipping.  A bug in an old version of NGM-LR sometimes
    # dropped the primary segment; the check for any non-hard-clipped segment provides
    # robustness to that bug.
    query_sequence_seg = None
    for s in readsegs:
        if s.query_sequence is not None:
            if (not s.is_secondary and not s.is_supplementary) or (
                s.cigartuples[0][0] != HARD_CLIP and s.cigartuples[-1][0] != HARD_CLIP):
                query_sequence_seg = s
                break

    assert query_sequence_seg is not None, \
        "no segment for read %s with full, unclipped query sequence" % (query_name)
    query_sequence = query_sequence_seg.query_sequence
    query_qualities = query_sequence_seg.query_qualities
    query_sequence_revcomp, query_qualities_revcomp = None, None # only calculate if needed

    # split the confidently and ambiguously mapped segments
    confidentreadsegs, ambiguousreadsegs, unmappedreadsegs = [], [], []
    for r in readsegs:
        if r.is_unmapped:
            unmappedreadsegs.append(r)
        elif r.mapq < min_mapq:
            ambiguousreadsegs.append(r)
        else:
            confidentreadsegs.append(r)

    # consider chaining confidently mapped segments on the same reference
    # chrom and strand and from the same mate
    confidentreadsegs_bychromstrandmate = defaultdict(list)
    for s in confidentreadsegs:
        k = s.reference_id, s.is_reverse, s.is_read1
        confidentreadsegs_bychromstrandmate[k].append(s)

    update_sa = False
    chainedreadsegs = []
    for segs in confidentreadsegs_bychromstrandmate.values():
        # start with the segment with the lowest reference coordinate and greedily
        # extend it into a colinear chain, marking segments that are incorporated
        # into the chain as consumed.  The greedy extension right aligns gaps.
        # Continue until no segments remain.
        sortedsegs = list(sorted(segs, key=lambda x: x.reference_start))
        consumed = set()
        for s0 in sortedsegs:
            if s0 not in consumed:  # segment is not yet in a chain
                # Create a new chain starting with s0
                consumed.add(s0)

                schain_reference_start = s0.reference_start
                schain_reference_end = s0.reference_end
                schain_cigartuples = deque(s0.cigartuples)
                s0_hcleft, dummy_s0_scleft, dummy_s0_hcright, dummy_s0_scright = stripclipping(schain_cigartuples)
                schain_query_alignment_start = s0_hcleft + s0.query_alignment_start
                schain_query_alignment_end = s0_hcleft + s0.query_alignment_end
                schain_mapping_quality = s0.mapping_quality
                schain_is_primary = (not s0.is_secondary and not s0.is_supplementary)
                schain_is_secondary = s0.is_secondary
                schain_segcount = 1

                # try to chain with other segments
                for s1 in sortedsegs:
                    if (s1 in consumed or s1.reference_start <= schain_reference_start or
                        skip_chain_alns_f(s0, s1)):
                        continue

                    s1cigartuples = deque(s1.cigartuples)
                    s1_hcleft, dummy_s1_scleft, dummy_s1_hcright, dummy_s1_scright = stripclipping(
                        s1cigartuples)
                    colinear = (schain_reference_start < s1.reference_start) and \
                        (schain_reference_end < s1.reference_end) and \
                        (schain_query_alignment_start < (s1_hcleft + s1.query_alignment_start)) and \
                        (schain_query_alignment_end <
                         (s1_hcleft + s1.query_alignment_end))

                    if not colinear:
                        continue

                    # The alignment s1 might overlap in part with schain. Move along s1 until
                    # it passes the end of schain in both query and reference coordinates.
                    # This loop is guaranteed to terminate by the definition of colinear:
                    # s1 extends beyond the end of schain.
                    querygap = s1_hcleft + s1.query_alignment_start - schain_query_alignment_end
                    refgap = s1.reference_start - schain_reference_end
                    while querygap < 0 or refgap < 0:  # negative gap means an overlap
                        op, oplen = s1cigartuples.popleft()
                        queryoplen, refoplen = (oplen if op in QUERYOPS else 0), (oplen if op in REFOPS else 0)
                        # Only move to the end of schain, not beyond
                        if queryoplen + querygap >= 0 and refoplen + refgap >= 0:
                            origoplen = oplen
                            if querygap < 0 and refgap < 0:
                                oplen = min(-querygap, -refgap)
                            elif querygap < 0:
                                oplen = -querygap
                            elif refgap < 0:
                                oplen = -refgap

                            if oplen < origoplen:
                                s1cigartuples.appendleft((op, origoplen - oplen))
                                queryoplen, refoplen = (oplen if op in QUERYOPS else 0), (oplen if op in REFOPS else 0)
                        querygap, refgap = querygap + queryoplen, refgap + refoplen

                    # Add s1 to the chain if the gap between chain links is not
                    # too large.
                    if querygap > max_gap or refgap > max_gap:
                        continue

                    consumed.add(s1)
                    schain_segcount += 1
                    mingap = min(querygap, refgap)
                    querygap -= mingap
                    refgap -= mingap
                    if mingap:  # force matches in double-sided gaps; it would be better to try to align
                        schain_cigartuples.append((MATCH, mingap))
                    if querygap > 0:
                        schain_cigartuples.append((INS, querygap))
                    if refgap > 0:
                        schain_cigartuples.append((DEL, refgap))
                    schain_cigartuples += s1cigartuples
                    schain_reference_end = s1.reference_end
                    schain_query_alignment_end = s1_hcleft + s1.query_alignment_end
                    schain_mapping_quality = max(schain_mapping_quality, s1.mapping_quality)
                    schain_is_primary = schain_is_primary or (
                        not s1.is_secondary and not s1.is_supplementary)
                    schain_is_secondary = schain_is_secondary and s1.is_secondary

                # only one segment (not really a chain)
                if schain_segcount == 1:
                    schain = s0
                else:  # multi-segment chain (i.e. an actual chain)
                    schain = AlignedSegment()
                    schain.query_name = s0.query_name
                    schain.reference_id = s0.reference_id
                    schain.reference_start = schain_reference_start
                    schain.mapping_quality = schain_mapping_quality
                    if schain_is_primary:  # the chain is the new primary alignment, which must not have hard clipping
                        schain_hcleft, schain_hcright = 0, 0
                    else:  # use hard clipping for non-primary alignments
                        schain_hcleft, schain_hcright = (schain_query_alignment_start, len(
                            query_sequence) - schain_query_alignment_end)
                    schain_scleft = schain_query_alignment_start - schain_hcleft
                    schain_scright = len(
                        query_sequence) - schain_query_alignment_end - schain_hcright
                    if schain_scleft:
                        schain_cigartuples.appendleft(
                            (SOFT_CLIP, schain_scleft))
                    if schain_hcleft:
                        schain_cigartuples.appendleft(
                            (HARD_CLIP, schain_hcleft))
                    if schain_scright:
                        schain_cigartuples.append((SOFT_CLIP, schain_scright))
                    if schain_hcright:
                        schain_cigartuples.append((HARD_CLIP, schain_hcright))
                    schain.cigartuples = schain_cigartuples
                    schain.next_reference_id = s0.next_reference_id
                    schain.next_reference_start = s0.next_reference_start
                    schain.template_length = s0.template_length
                    schain.flag = s0.flag
                    schain.is_secondary = schain_is_secondary
                    schain.is_supplementary = not schain.is_secondary and not schain_is_primary
                    update_sa = update_sa or not schain.is_secondary

                    if schain.is_reverse == query_sequence_seg.is_reverse: # schain and query_sequence_seg have same strand
                        qseq, qqual = query_sequence, query_qualities
                    else:
                        if query_sequence_revcomp is None: # calculate revcomp if it has not been done
                            query_sequence_revcomp = revcomp(query_sequence)
                            query_qualities_revcomp = None if query_qualities is None else revqual(query_qualities)
                        qseq, qqual = query_sequence_revcomp, query_qualities_revcomp
                    qstart, qend = (schain_hcleft, len(query_sequence) - schain_hcright)
                    schain.query_sequence = qseq[qstart:qend]
                    schain.query_qualities = None if qqual is None else qqual[qstart:qend]

                    # "XC" denotes the number of segments that were chained to form this one
                    schain.set_tag("XC", schain_segcount, value_type="i")
                    if s0.has_tag("RG"):
                        rgval, rgtype = s0.get_tag("RG", with_value_type=True)
                        schain.set_tag("RG", rgval, value_type=rgtype)

                # output the chain
                chainedreadsegs.append(schain)

    # update the "SA" tags if a primary or supplementary alignment is chained
    if update_sa:
        primaryseg, supplementarysegs = None, []
        for s in chainedreadsegs + ambiguousreadsegs:
            if s.is_supplementary:
                supplementarysegs.append(s)
            elif not s.is_secondary:
                primaryseg = s

        allsegs = ([] if primaryseg is None else [primaryseg]) + supplementarysegs
        for s0 in allsegs:
            sa_tags = []
            for s1 in allsegs:
                if s1 != s0:
                    sa_tags.append(",".join([str(x) for x in [refidtoname[s1.reference_id], s1.reference_start,
                                                              "-" if s1.is_reverse else "+", s1.cigarstring, s1.mapping_quality, 0]]))
            s0.set_tag("SA", ";".join(sa_tags) if len(sa_tags) else None)

    return sorted(chainedreadsegs + ambiguousreadsegs, key=lambda x: (x.reference_id, x.reference_start)) + unmappedreadsegs


def chain_all(bamin, bamout, cfg=None, write_translocation_f=None):
    """Chain alignments in input bam to output bam.
    bamin --- input sam/bam file path
    bamout --- output sam/bam file path
    cfg --- either SVConfig obj or file path
    """
    # FIXME: refactor needed, SAT-780
    log.info("chain_all(%r, %r, %r)", bamin, bamout, cfg)
    if is_stdin(bamin):
        bamin = AlignmentFile(bamin, 'rb', check_sq=False)
    else:
        bamin = BamStream(bamin, None, False)

    bamout_fn, bamout_fmt = autofmt(bamout, ("bam", "sam"), "bam")
    bamout = AlignmentFile(bamout_fn, "w" + ("b" if bamout_fmt == "bam" else "h"), header=bamin.header)

    cfg = get_config(cfg)

    querynames = set()  # query names seen thus far
    readsegs = []      # list of aligned segments for the current read
    # The input BAM must be grouped by query name, which is validated as the
    # file is read.
    for scur in bamin:
        # group segments from the same read; chain the segments for the
        # previous read when a new read is found
        if len(readsegs) and readsegs[0].query_name != scur.query_name:
            # new read; confirm it has not been seen before
            assert scur.query_name not in querynames, \
                "segments for read %s not grouped" % (scur.query_name)
            # tag inversions
            has_inversion = tag_inversions(readsegs, inversion_poswiggle=cfg.inversion_poswiggle)
            if not has_inversion:
                tag_translocations(readsegs, translocation_poswiggle=500, out_handler_f=write_translocation_f)
            # process the previous read
            for s in chain(readsegs=readsegs, min_mapq=cfg.chain_min_mapq, max_gap=cfg.chain_max_gap,
                           skip_chain_alns_f=are_both_inv_or_flank_alns):
                bamout.write(s)
            readsegs = []  # free the segments for the previous read
        querynames.add(scur.query_name)
        readsegs.append(scur)
    # process the last read
    if len(readsegs):
        for s in chain(readsegs, cfg.chain_min_mapq, cfg.chain_max_gap, are_both_inv_or_flank_alns):
            bamout.write(s)

    bamin.close()
    bamout.close()
