"""pbsv VCF|BED IO.
Note classes are NOT for generic Vcf|BED IO.
"""
from __future__ import absolute_import

import datetime
import traceback
import re
from collections import defaultdict
from ..independent.iobase import WriterBase, ReaderBase
from ..independent.common import SvType, SvFmt, SvFmts, SvAnnot, SvAnnotations
from ..independent.utils import items_to_str


# List of important public classes.
#__all__ = ["VcfRecord", "VcfReader", "VcfWriter", "BedRecord", "BedReader", "BedWriter"]

PBSV_VCF_META = \
"""##fileformat=VCFv4.2
##fileDate={today}
##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description="Imprecise structural variant">
##INFO=<ID=SVTYPE,Number=1,Type=String,Description="Type of structural variant">
##INFO=<ID=END,Number=1,Type=Integer,Description="End position of the structural variant described in this record">
##INFO=<ID=SVLEN,Number=.,Type=Integer,Description="Difference in length between REF and ALT alleles">
##INFO=<ID=SVANN,Number=.,Type=String,Description="Repeat annotation of structural variant">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=AD,Number=1,Type=Integer,Description="Per-sample read depth of this structural variant">
##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Read depth at this position for this sample">
""".format(today=datetime.date.today().strftime('%Y%m%d')) # fileData=YYYYMMDD

PBSV_VCF_HEADER_COLUMNS = ["CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT"]

def PBSV_VCF_HEADER(samples):
    return "#" + "\t".join(PBSV_VCF_HEADER_COLUMNS + samples)

PBSV_BED_HEADER_COLUMNS = ['CHROM', 'START', 'END', 'ID', 'SVTYPE', 'SVLENGTH', 'ALT', 'QUAL', 'FILTER', 'INFO', 'FORMAT']

def PBSV_BED_HEADER(samples):
    return '#' + '\t'.join(PBSV_BED_HEADER_COLUMNS + samples)

__WHITESPACE_PATTERN__ = re.compile(r'\s+')
def _str2chrom(s):
    """VCF4.2 CHROM - chromosome: An identifier from the reference genome or an angle-bracketed ID String (<ID>)
    pointing to a contig in the assembly file (cf. the ##assembly line in the header). All entries for a specific
    CHROM should form a contiguous block within the VCF file. The colon symbol (:) must be absent from all
    chromosome names to avoid parsing errors when dealing with breakends. (String, no white-space permitted,
    Required)."""
    s = re.sub(__WHITESPACE_PATTERN__, '_', s)
    s = s.replace(':', '_')
    return s


def _2str(s):
    """Convert s to a string. Return '.' if s is None or an empty string."""
    return '.' if s is None or str(s) == '' else str(s)


def _get_annotations(annotations):
    """Return a list of annotations. If input is None or [], return [SvAnnot.OTHER]"""
    if isinstance(annotations, SvAnnotations):
        return annotations
    if annotations is None or len(annotations) == 0:
        return SvAnnotations([SvAnnot.OTHER])
    else:
        return SvAnnotations([SvAnnot(a) for a in annotations])


def _get_sv_type(sv_type, sv_annot):
    """Return SvType. SAT-1283, only allow SvType = DEL, INS or INV, no DUP"""
    return SvType(sv_type)


def _get_alt(sv_type, sv_annot):
    """Return vcf column 4 alt string e.x., <DEL>, <INS>, <DEL:ME:L1>, <INS:ME:ALU>
    SAT-1283, NO SVTYPE=DUP """
    sv_type = SvType(sv_type)
    sv_annot = SvAnnot(sv_annot)
    if sv_annot.is_ME:
        return '<%s:ME:%s>' % (sv_type.to_vcf_str(), sv_annot)
    else:
        return '<%s>' % (sv_type.to_vcf_str())


def _transpaths_to_str(transpaths):
    return ','.join(transpaths)

def _str_to_transpaths(s):
    return s.split(',')


def _parse_info(info):
    """parse info, e.x., IMPRECISE;SVTYPE=DEL;END=321887;SVLEN=-105;SVANN=OTHER;TRANSPATHS=(bnd_1,band_2),(bnd_4,bnd_5)
    Return (sv_type, sv_len, end, sv_annot, transpaths) """
    try:
        d = defaultdict(str)
        for x in info.split(';'):
            if len(x) > 0 and '=' in x:
                k, v = x.split('=')
                d[k] = v

        transpaths = [] if len(d['TRANSPATHS'])==0 else _str_to_transpaths(d['TRANSPATHS'])
        return (SvType(d['SVTYPE']), int(d['SVLEN']), int(d['END']), SvAnnotations.fromString(d['SVANN']), transpaths)
    except (ValueError, KeyError) as e:
        raise ValueError('info %r must have SVTYPE, END, SVLEN and SVANN: %r' %(info, e))


def to_pbsv_id(sv_type, index):
    """Return a string to represent a sv id.
    ...doctest:
        >>> to_pbsv_id(SvType.Insertion, 1)
        'pbsv.INS.1'
    """
    return 'pbsv.{}.{}'.format(SvType(sv_type).to_vcf_str(), index)


class VcfRecord(object):
    """Vcf Object
    2 321682    . T <DEL>   6 PASS    IMPRECISE;SVTYPE=DEL;END=321887;SVLEN=-105;SVANN=OTHER  GT:AD:DP 0/1:3:12 0/1:1:15
    ...doctest:
        >>> s = 'X\\t1000\\t.\\tT\\t<INS:ME:SVA_A>\\t.\\tPASS\\tIMPRECISE;SVTYPE=INS;END=1000;SVLEN=466;SVANN=SVA_A\\tGT:AD:DP\\t1/1:7:10\\t./.:3:6'
        >>> samples = ['SAMPLE1', 'SAMPLE2']
        >>> s == VcfRecord.fromString(s, samples).to_str(samples)
        True
    """
    __sep__ = '\t'

    def __init__(self, chrom, pos, ref, alt, fmts, annotations, end, sv_type, sv_len, sv_id='.', transpaths=None):
        self.annotations = _get_annotations(annotations)
        self.end = int(end)
        self.sv_type = _get_sv_type(sv_type=sv_type, sv_annot=self.annotations[0])
        self.sv_len = int(sv_len)
        self.chrom = _str2chrom(chrom) # column 0
        self.pos = int(pos) # column 1, start pos of sv in reference
        self.sv_id = _2str(sv_id) # column 2, pbsv id
        self.ref = ref # column 3
        self.alt = alt # column 4, single alt, can either be a sequence, or a symbolic allele e.g., <DEL>
        if alt is None: # infer alt if exact sequence is not provided
            self.alt = _get_alt(sv_type=self.sv_type, sv_annot=self.annotations[0])
        self.qual = '.' # column 5, no qual at this point
        self.filt = 'PASS' # column 6, no filter at this point
        # column 7 info
        # column 8 SvFmt.FMT, GT:AP:DP
        if not isinstance(fmts, SvFmts):
            raise ValueError("fmts be a SvFmts object, while it is %s" % (type(fmts)))
        self.fmts = fmts # columns 9, 10, ... represent formats of samples in order
        self.transpaths = transpaths # e.g., ['(e0,e1,e2)', '(e3,e4)' ]

    @property
    def info(self):
        """vcf column 7 info. e.x., 'IMPRECISE;SVTYPE=DEL;END=321887;SVLEN=-105;SVANN=L1' or 'IMPRECISE;SVTYPE=DEL;END=321887;SVLEN=-105;'"""
        infos = ['IMPRECISE', 'SVTYPE=%s' % self.sv_type.to_vcf_str(),
                 'END=%s' % self.end, 'SVLEN=%s' % self.sv_len, "%s" % self.annotations.to_vcf_str()]
        if self.transpaths:
            infos.append('TRANSPATHS={}'.format(_transpaths_to_str(self.transpaths)))
        return ';'.join([x for x in infos if len(x) != 0])

    @property
    def samples(self):
        return self.fmts.samples

    def __str__(self):
        raise NotImplementedError()

    def to_str(self, samples):
        fs = [self.chrom, self.pos, self.sv_id, _2str(self.ref), self.alt, self.qual, self.filt, self.info, SvFmt.FMT, self.fmts.to_str(samples=samples)]
        return items_to_str(fs, self.__sep__)

    def set_pbsv_id(self, index):
        self.sv_id = to_pbsv_id(self.sv_type, index)
        return self

    def __repr__(self): # brief info
        fs = [self.chrom, self.pos, self.info, repr(self.fmts)]
        return items_to_str(fs, self.__sep__)

    @classmethod
    def fromString(cls, s, samples):
        """Create a VcfRecord from a string"""
        CHROM_IDX, POS_IDX, SV_ID_IDX, REF_IDX, ALT_IDX, QUAL_IDX, FILT_IDX, INFO_IDX, FORMAT_IDX = range(0, 9)
        fs = s.split(cls.__sep__)
        lfs = len(PBSV_VCF_HEADER_COLUMNS) + len(samples) # total number of columns
        if len(fs) < lfs:
            raise ValueError("Vcf record must have at least {!r} columns".format(lfs))
        if fs[FORMAT_IDX] != SvFmt.FMT:
            raise ValueError("Format %s is not %s" % (fs[FORMAT_IDX], SvFmt.FMT))
        sv_type, sv_len, end, annotations, transpaths = _parse_info(fs[INFO_IDX])
        # support old format in which sv_len of DEL SV is positive
        if sv_type.is_Deletion:
            sv_len = -abs(int(sv_len))
        fmts = SvFmts.fromString(s='\t'.join(fs[len(PBSV_VCF_HEADER_COLUMNS):lfs]), samples=samples)
        return VcfRecord(chrom=fs[CHROM_IDX], pos=fs[POS_IDX], ref=fs[REF_IDX], alt=fs[ALT_IDX], fmts=fmts,
                         annotations=annotations, end=end,
                         sv_type=sv_type, sv_len=sv_len, sv_id=fs[SV_ID_IDX], transpaths=transpaths)


class VcfWriter(WriterBase):
    """ pbsv vcf writer."""
    def __init__(self, f, samples):
        """
        samples --- a list of samples, specify the order in which samples' formats should write.
        """
        super(VcfWriter, self).__init__(f)
        self.samples = list(samples)
        self._write_meta_lines()
        self._write_comment_lines()

    def _write_meta_lines(self):
        """Write meta info lines to out file."""
        self.file.write(PBSV_VCF_META)

    def _write_comment_lines(self):
        """Write comments/headers to out file."""
        self.file.write(PBSV_VCF_HEADER(samples=self.samples) + '\n')

    def writeRecord(self, record):
        """Write Vcf record."""
        if not isinstance(record, VcfRecord):
            raise ValueError("record type %s is not VcfRecord." % type(record))
        else:
            for s in self.samples:
                if s not in record.samples:
                    raise ValueError("Could not write VcfRecord %r because sample %r is not included in VcfWriter." % (repr(record), s))
            self.file.write("%s\n" % record.to_str(samples=self.samples))


def get_samples_from_file(f, leading_str):
    """Return a list of ordered samples from file.
    f --- iterate over lines of a file or strings
    ...doctest:
        >>> f = '#abc\\tsample0\\tsample1'
        >>> get_samples_from_file([f], '#abc')
        ['sample0', 'sample1']
    """
    for line in f:
        line = line.strip()
        if line.startswith(leading_str):
            return line[len(leading_str):].strip().split('\t')
        elif len(line) > 0 and line[0] != '#':
            break
    raise ValueError("Could not get samples")


class VcfReader(ReaderBase):
    """
    pbsv Vcf Reader
    ..doctest::
        >>> from pbsv1.io.VcfIO import VcfRecord, VcfReader, VcfWriter
        >>> samples = ['SAMPLE1', 'SAMPLE2']
        >>> v = VcfRecord(chrom='chr2', pos=321682, ref=None, alt='T', fmts=SvFmts.fromDict({'SAMPLE1':'0/1:3:12', 'SAMPLE2':'0/1:5:10'}), annotations='SVANNOT=OTHER', end=321887, sv_type='DEL', sv_len=-105)
        >>> fn = 'test_vcf_reader_example.vcf'
        >>> with VcfWriter(fn, samples=samples) as w: w.writeRecord(v)
        >>> [r.to_str(samples=samples) for r in VcfReader(fn)][0]
        'chr2\\t321682\\t.\\t.\\tT\\t.\\tPASS\\tIMPRECISE;SVTYPE=DEL;END=321887;SVLEN=-105\\tGT:AD:DP\\t0/1:3:12\\t0/1:5:10'
        >>> import os
        >>> os.remove(fn)
    """
    def __init__(self, f):
        super(VcfReader, self).__init__(f)
        self.samples = get_samples_from_file(self.file, PBSV_VCF_HEADER(['']))

    def __iter__(self):
        for line in self.file:
            line = line.strip()
            if len(line) > 0 and line[0] != '#':
                yield VcfRecord.fromString(line, samples=self.samples)


class BedRecord(object):
    """Bed Object
    chr1\t0\t100\t.\tDeletion\t-100\t.\t.\tPASS\tSVANN=OTHER\tGT:AD:DP\t0/1:3:6\t0/0:0:25
    """
    __sep__ = '\t'
    def __init__(self, chrom, start, end, sv_id, sv_type, sv_len, alt, annotations, fmts, transpaths=None):
        self.chrom = chrom # column 0, no need to convert chr1 to 1
        self.start = int(start) # column 1, 0 indexed, inclusive
        self.end = int(end) # column 2, 0 indexed, exclusive
        self.sv_id = _2str(sv_id) # column 3
        self.sv_type = SvType(sv_type) # column 4
        self.sv_len = int(sv_len) # column 5
        self.alt = alt # column 6, single alternative sequence, None, '.' or ({ATGCatgc}+)
        self.qual = '.' # column 7, no quality at this point
        self.filt = 'PASS' # column 8, no filter at this point
        # column 9, info
        # column 10, GT:AD:DP
        self.annotations = _get_annotations(annotations)
        self.fmts = fmts #column 11 and after
        self.transpaths = transpaths # e.g., ['(svid0,svid1)', '(svid2,svid3,svid4)']

    @property
    def info(self):
        """Bed column 0 info. e.x., 'SVANN=L1' or 'SVLEN=-105;'"""
        infos = ['IMPRECISE', 'SVTYPE=%s' % self.sv_type.to_bed_str(),
                 'END=%s' % self.end, 'SVLEN=%s' % self.sv_len, "%s" % self.annotations.to_bed_str()]
        if self.transpaths:
            infos.append('TRANSPATHS=%s' % (_transpaths_to_str(self.transpaths)))
        return ';'.join([x for x in infos if len(x) != 0])

    @property
    def samples(self):
        return self.fmts.samples

    def __str__(self):
        raise NotImplementedError()

    def to_str(self, samples):
        fs = [self.chrom, self.start, self.end, self.sv_id, self.sv_type, self.sv_len,
              _2str(self.alt), self.qual, self.filt, self.info, SvFmt.FMT, self.fmts.to_str(samples=samples)]
        return items_to_str(fs, self.__sep__)

    def set_pbsv_id(self, index):
        self.sv_id = to_pbsv_id(self.sv_type, index)
        return self

    def __repr__(self): # brief info
        fs = [self.chrom, self.start, self.end, self.info, repr(self.fmts)]
        return items_to_str(fs, self.__sep__)

    @classmethod
    def fromString(cls, s, samples):
        """Create a BedRecord from a string"""
        CHROM_IDX, START_IDX, END_IDX, SV_ID_IDX, SV_TYPE_IDX, SV_LEN_IDX, ALT_IDX, QUAL_IDX, FILT_IDX, INFO_IDX, FORMAT_IDX = range(0, 11)
        fs = s.split(cls.__sep__)
        lfs = len(PBSV_BED_HEADER_COLUMNS) + len(samples) # total number of columns
        if len(fs) < lfs:
            raise ValueError("Bed record must have {!r} columns".format(lfs))
        if fs[FORMAT_IDX] != SvFmt.FMT:
            raise ValueError("Format %s is not %s" % (fs[FORMAT_IDX], SvFmt.FMT))
        annotations = None
        if 'SVANN=' in fs[INFO_IDX]:
            annotations = SvAnnotations(fs[INFO_IDX].split('SVANN=')[1].split(';')[0].split(','))
        transpaths = None
        if 'TRANSPATH=' in fs[INFO_IDX]:
            transpaths = fs[INFO_IDX].split('TRANSPATH=').split(';')[0].split(',')
        sv_len = int(fs[SV_LEN_IDX])
        if SvType(fs[SV_TYPE_IDX]).is_Deletion:
            sv_len = -abs(int(sv_len))  # support old format in which sv_len of DEL SV is positive
        fmts = SvFmts.fromString(s='\t'.join(fs[len(PBSV_BED_HEADER_COLUMNS):lfs]), samples=samples)
        return BedRecord(chrom=fs[CHROM_IDX], start=fs[START_IDX], end=fs[END_IDX], sv_id=fs[SV_ID_IDX], sv_type=fs[SV_TYPE_IDX],
                         sv_len=sv_len, alt=fs[ALT_IDX], fmts=fmts, annotations=annotations, transpaths=transpaths)


class BedWriter(WriterBase):
    """ pbsv bed writer."""
    def __init__(self, f, samples):
        super(BedWriter, self).__init__(f)
        self.samples = list(samples)
        self._write_comment_lines()

    def _write_comment_lines(self):
        """Write comments/headers to out file."""
        self.file.write(PBSV_BED_HEADER(self.samples) + '\n')

    def writeRecord(self, record):
        """Write Bed record."""
        if not isinstance(record, BedRecord):
            raise ValueError("record type %s is not BedRecord." % type(record))
        else:
            for s in self.samples:
                if s not in record.samples:
                    raise ValueError("Could not write VcfRecord %r because sample %r is not included in VcfWriter." % (repr(record), s))
            self.file.write("%s\n" % record.to_str(samples=self.samples))


class BedReader(ReaderBase):
    """
    pbsv Bed Reader
    ..doctest::
        >>> from pbsv1.io.VcfIO import BedRecord, BedReader, BedWriter
        >>> samples = ['SAMPLE1', 'SAMPLE2']
        >>> v = BedRecord(chrom='chr2', start=321682, end=321887, sv_id='.', sv_type='DEL', sv_len=-105, alt=None, annotations=None, fmts=SvFmts.fromDict({'SAMPLE1':'0/1:3:12', 'SAMPLE2':'0/1:5:10'}))
        >>> fn ='test_bed_reader_example.bed'
        >>> with BedWriter(fn, samples=samples) as w: w.writeRecord(v)
        >>> reads = [r for r in BedReader(fn)]
        >>> reads[0].to_str(samples=samples)
        'chr2\\t321682\\t321887\\t.\\tDeletion\\t-105\\t.\\t.\\tPASS\\tIMPRECISE;SVTYPE=Deletion;END=321887;SVLEN=-105;.\\tGT:AD:DP\\t0/1:3:12\\t0/1:5:10'
        >>> reads[0].to_str(samples=samples[::-1])
        'chr2\\t321682\\t321887\\t.\\tDeletion\\t-105\\t.\\t.\\tPASS\\tIMPRECISE;SVTYPE=Deletion;END=321887;SVLEN=-105;.\\tGT:AD:DP\\t0/1:5:10\\t0/1:3:12'
        >>> import os
        >>> os.remove(fn)
    """
    def __init__(self, f):
        super(BedReader, self).__init__(f)
        self.samples = get_samples_from_file(self.file, leading_str=PBSV_BED_HEADER(['']))

    def __iter__(self):
        lineno = 0
        for line in self.file:
            lineno += 1
            line = line.strip()
            if len(line) > 0 and line[0] != '#':
                try:
                    yield BedRecord.fromString(line, samples=self.samples)
                except Exception as err:
                    msg = '{}\nError reading line {} of BED input:\n{}\n{!r}'.format(
                            traceback.format_exc(),
                            lineno, line, err)
                    raise Exception(msg)
