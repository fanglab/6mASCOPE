"""Mark duplicate alignments."""
from __future__ import absolute_import

import re
import collections

from .libs import AlignmentFile, AlignedSegment
from .utils import autofmt
from .independent.utils import (is_json, join_dict, readname2moviename, add_readgroups_to_header)
from .io.bamstream import (get_movienames2readgroups_from_header,
        get_or_generate_movienames2samples, __header_dict)


markdup_desc = """Identify and tag duplicate alignments that originate from the same DNA
fragment; in addition, add RG with SM to BAM header, and add 'RG' to all output alignments.
Duplicates have two forms: "subreads duplicates" from a single
ZMW, and "PCR duplicates" from amplification of a single source fragment
in a library and subsequent sequencing on separate ZMWs. Duplicates are
identified as alignments with the same read library, reference start
coordinate and reference end coordinate (within specified tolerance).
"""

markdup_epilog = """ZMW NAME
    ZMW name consists of the {movieName}/{holeNumber}.  The ZMW name is
    inferred from the read name if it follows the PacBio conventions of
    {movieName}/{holeNumber}/{qStart}_{qEnd} or {movieName}/{holeNumber}/ccs.
    Read names that do not follow the convention are treated as from a
    unique ZMW.

ONE-SIDED EQUIVALENCE
    It is recommended not to use --onesided without --samezmw, as it is
    otherwise too lax and marks most alignments as duplicates.

MEMORY USAGE
    The --onesided option increases memory usage, particularly if the input
    includes alignments with large reference spans.
"""


def make_readgroups(template_header, movienames2samples_json):
    """Make readgroups for markduplicate output bam header.
    * get subeads BAM RG read groups
    * add SM tag to all RG read groups, where we infer {sample: readgroup} by assuming a
      movie has exactly sample, and dict {moviename: sample} can be obtained or generated.
    """
    movienames2readgroups = get_movienames2readgroups_from_header(template_header) # {moviename: readgroup}
    movienames2samples = get_or_generate_movienames2samples(movienames2samples_json, movienames2readgroups.keys())
    readgroups2samples = join_dict(movienames2readgroups, movienames2samples)
    # Add SM tag to all RG groups.
    for rg in template_header['RG']:
        rg['SM'] = readgroups2samples[rg['ID']]
    return template_header['RG']


def markdup(bamin, bamout, tolerance, onesided, samezmw, readgroups, modify_alignedseg_f=None):

    """function to mark duplicate alignments in bamin, mark the duplicate
    tag, and also set sample tag 'sm' to every AlignedSegment if applicable,
    and write to bamout.
    header -- BAM header of the output alignment file. Updated Aug 21 2017, we used to use
    input BAM header as the template header. To include RG read groups in header and add
    SM tags to read groups, we now pre-compute header.
    modify_alignedseg_f -- function to modify AlignedSegment objects
    """

    # Regular expression to extract ZMW name (movie+holeNumber) if read name
    # follows the "{movieName}/{holeNumber}/{qStart}_{qEnd}" or "{movieName}/{holeNumber}/ccs"
    # PacBio conventions.
    zmwre = re.compile("^([^/]+/[^/]+)/(ccs|([0-9]+_[0-9]+))$")

    # Open input and output file.
    bamin, infmt = autofmt(bamin, ("bam", "sam"), "bam")
    bamin = AlignmentFile(bamin, "r" + ("b" if infmt == "bam" else ""))

    header = add_readgroups_to_header(header=__header_dict(bamin.header), readgroups=readgroups)
    bamout, outfmt = autofmt(bamout, ("bam", "sam"), "bam")
    bamout = AlignmentFile(bamout, "w" + ("b" if outfmt == "bam" else "h"), header=header)

    # Map from read group to library name.
    rgidtolib = dict()
    for rg in bamin.header.get("RG", []):
        assert rgidtolib.get(rg["ID"], rg.get("LB")) == rg.get("LB")
        rgidtolib[rg["ID"]] = rg.get("LB")

    # The input BAM must be coordinate sorted.  Validate as the file is read.
    refids = set()  # reference sequence IDs seen so far
    segix = 0      # serial number of aligned segments from the input file

    # Process the input BAM segment-by-segment.  Remember segments until a subsequent
    # segment is reached that starts too far away to possibly be a duplicate.
    sprev = None  # previous aligned segment
    activesegs = collections.deque()  # unflushed segments
    activesegsbyzmw = collections.defaultdict(
        collections.deque)  # unflushed segments grouped by ZMW
    objectidtozmwandlib = dict()  # map from object ID to (zmwName,libName)
    for scur in bamin:
        segix += 1

        # check sort order
        soviolation = False
        if sprev:
            if sprev.reference_id != scur.reference_id:  # new reference sequence
                if scur.reference_id in refids:  # if sequence has been seen before its alignments are not grouped
                    soviolation = True
            elif sprev.reference_start > scur.reference_start:
                soviolation = True
        if soviolation:
            raise ValueError("Input file must be sorted by coordinate.\n" +
                             "Sort order violation at alignment #%d: %s @ %s:%d" % (segix, scur.query_name,
                                                                                    bamin.get_reference_name(scur.reference_id), scur.reference_start + 1))

        # Modify AlignedSegment object scur if applicable
        if modify_alignedseg_f:
            scur = modify_alignedseg_f(scur)

        # Flush segments that will not be duplicates to this or any subsequent segment
        # If equivalence of both start and end coordinates are required, flush the segments
        # with a start coordinate that can never find another matching start coordinate;
        # if one-sided equivalence is permitted, then flush the segments where neither coordinate
        # can find another match.  The one-sided mode potentially requires keeping many more
        # segments in memory.  One segment with a hugh span will clog up the flow of the
        # subsequent segments until its reference_end is reached.
        flushattr = "reference_end" if onesided else "reference_start"
        while len(activesegs) and (activesegs[0].is_unmapped or
                                   activesegs[0].reference_id != scur.reference_id or
                                   (getattr(activesegs[0], flushattr) + tolerance) < scur.reference_start):
            s = activesegs.popleft()
            szmw, dummy_slib = objectidtozmwandlib[id(s)]
            del objectidtozmwandlib[id(s)]  # clean outdated value
            # remove `s` from the byzmw deque too
            activesegsbyzmw[szmw].popleft()
            bamout.write(s)

        # infer the ZMW from the segment name
        m = zmwre.match(scur.query_name)
        # segix is a unique integer and can not collide with a string
        scurzmw = m.group(1) if m else segix
        # obtain the library name from the read group (if available)
        scurlib = rgidtolib.get(scur.get_tag(
            "RG")) if scur.has_tag("RG") else None
        objectidtozmwandlib[id(scur)] = scurzmw, scurlib

        # check if the segment is a duplicate
        if not scur.is_unmapped:
            sothers = activesegsbyzmw.get(
                scurzmw, []) if samezmw else activesegs
            for sother in sothers:
                dummy_sotherzmw, sotherlib = objectidtozmwandlib[id(sother)]
                # alignment can not be duplicate of an unmapped read
                if sother.is_unmapped:
                    continue
                # alignment can not be duplicate of another alignment for the
                # same read
                if sother.query_name == scur.query_name:
                    continue
                # alignments are not duplicates if they are from reads in different libraries;
                # assume the library is the same if it is unknown for either
                # read
                if sotherlib is not None and scurlib is not None and sotherlib != scurlib:
                    continue

                # check for coordinate equivalence
                startcoordequal = scur.reference_start - sother.reference_start <= tolerance
                endcoordequal = abs(scur.reference_end -
                                    sother.reference_end) <= tolerance
                if (startcoordequal and endcoordequal) or (onesided and (startcoordequal or endcoordequal)):
                    # Mark the segment with the shorter aligned reference length as a duplicate.
                    # If the segments have same aligned reference length, prefer the read name that
                    # is first alphabetically as non-duplicate.  For reads with the same name, prefer
                    # the one that appears first in the input file (`sother`) as non-duplicate.
                    # `reference_length` is negated so that length and query name have same sort direction
                    scur.is_duplicate = (-scur.reference_length, scur.query_name, 1) > (-sother.reference_length, sother.query_name, 0)
                    sother.is_duplicate = not scur.is_duplicate

        # add the segment to the active queue
        activesegs.append(scur)
        activesegsbyzmw[scurzmw].append(scur)

    # flush any remaining segments
    while len(activesegs):
        s = activesegs.popleft()
        szmw, dummy_slib = objectidtozmwandlib[id(s)]
        del objectidtozmwandlib[id(s)]
        activesegsbyzmw[szmw].popleft()
        bamout.write(s)

    bamin.close()
    bamout.close()
