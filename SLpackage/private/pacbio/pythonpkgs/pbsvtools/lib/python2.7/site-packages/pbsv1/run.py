"""
pbsv1 end to end pipeline,
inputs: reads.bam + ref.fa
outputs: sv calls.bed
steps: ngmlr, markduplicates, chain, svcall
"""
from __future__ import absolute_import

import getpass
import logging
import os
import os.path as op
import tempfile
from .independent.utils import (realpath, mktemp_cmd, mv_cmd, bai_of_bam,
        execute_as_bash, backticks, is_bam, is_subreadset, transpaths_of_bam)
from .config import get_config, get_config_and_tmp_dir, make_cfg_fn


log = logging.getLogger()

# List of important public functions or classes.
#__all__ = ["SVFiles", "svalign", "svrun"]


def _mktemp(prefix="/scratch/tmp.pbsv."):
    """Make a local tmp dir at /scratch/tmp.pbsv.XXXXXX, and return path.
    Prefix should be a full path, and parent-dir must already exist.
    If parent-dir does not exist, auto-try tempfile.gettempdir() instead (TMPDIR/TEMP/TMP).
    """
    parent = op.dirname(prefix)
    basename = op.basename(prefix)
    if not op.isdir(parent):
        parent = tempfile.gettempdir()
        prefix = op.join(parent, basename)
    assert op.isdir(parent), 'Parent of tmp dir {!r} must exist, since we do not know what shared permissions to use'.format(
            prefix)
    o, dummy_c, dummy_e = backticks(mktemp_cmd(prefix))
    return o[0]


def _mktemp_with_user_pid(tmp_root_dir, tmp_dirname):
    """Make a temp dir with user id and group id, return temp dir path."""
    tmp_dir = op.join(_mktemp(op.join(tmp_root_dir, tmp_dirname)), str(getpass.getuser()), str(os.getpid()))
    log.info('Using temporary directory: {!r}'.format(tmp_dir))
    _mkdir(tmp_dir)
    return tmp_dir

class SVFiles(object):

    """pbsv files"""

    def __init__(self, root_dir):
        self.root_dir = realpath(root_dir)

    @property
    def ngmlr_bam(self):
        """ngmlr.bam"""
        return op.join(self.root_dir, 'ngmlr.bam')

    @property
    def markdup_bam(self):
        """markdup.bam"""
        return op.join(self.root_dir, 'markdup.bam')

    @property
    def chain_bam(self):
        """chain.bam"""
        return op.join(self.root_dir, 'chain.bam')

    @property
    def chain_sam(self):
        """chain.sam"""
        return op.join(self.root_dir, 'chain.sam')

    @property
    def sorted_chain_bam(self):
        """sorted_chain.bam"""
        return op.join(self.root_dir, 'sorted_chain.bam')


def map_subreads_cmd(ref_fn, in_bam, out_bam, cfg):
    """Return cmd for ngmlr `pbsv1util ngmlr` or `pbsv1util minimap2`"""
    cfg = get_config(cfg)
    assert cfg.cfg_fn is not None
    aligner = cfg.subreads_aligner # pylint: disable=no-member
    assert aligner in ['ngmlr', 'minimap2'], 'Invalid Subreads Aligner {}'.format(aligner)
    c0 = "pbsv1util {aligner} {ref_fn} {in_bam} {out_bam} --cfg_fn {cfg_fn}".format(
        aligner=aligner, ref_fn=ref_fn, in_bam=in_bam, out_bam=out_bam, cfg_fn=cfg.cfg_fn)
    return c0


def markdup_cmd(in_bam, out_bam, template_bam, cfg, tmp_dir, movienames2samples_json):
    """Return cmd for mark duplicates"""
    cfg, tmp_dir = get_config_and_tmp_dir(cfg, tmp_dir)
    assert cfg.cfg_fn is not None
    srt_dir = '{tmp_dir}/msrt'.format(tmp_dir=tmp_dir)
    cx = 'mkdir -p {srt_dir}'.format(srt_dir=srt_dir)
    c00 = 'samtools view -H {in_bam}'.format(in_bam=in_bam)
    c01 = 'samtools view {in_bam} | sort --stable -T {srt_dir} -k1,1'.format(in_bam=in_bam, srt_dir=srt_dir)
    c0 ='({} ; ({}))'.format(c00, c01)
    c1 = "samtools sort --threads {nproc} -T {tmp_dir}/srt -".format(nproc=cfg.nproc, tmp_dir=tmp_dir)
    c2 = "pbsv1util markduplicates - {out_bam} --cfg_fn {cfg_fn} --template_bam {template_bam}".format(
        template_bam=template_bam, cfg_fn=cfg.cfg_fn, out_bam=out_bam)
    if movienames2samples_json:
        c2 += ' --movienames2samples {json}'.format(json=movienames2samples_json)
    return cx + ' ; ' + ' | '.join([c0, c1, c2])


def chain_cmd(in_bam, out_sam, cfg, tmp_dir):
    """chain alignments"""
    cfg_fn = cfg if isinstance(cfg, str) else cfg.cfg_fn
    assert cfg_fn is not None
    srt_dir = '{tmp_dir}/csrt'.format(tmp_dir=tmp_dir)
    cx = 'mkdir -p {srt_dir}'.format(srt_dir=srt_dir)
    c0 = "samtools view {in_bam}".format(in_bam=in_bam)
    c1 = "sort --stable -T {srt_dir} -k1,1".format(srt_dir=srt_dir)
    c2 = "cat <(samtools view -H {in_bam} -) -".format(in_bam=in_bam)
    c3 = "pbsv1util chain - {out_sam} --cfg_fn {cfg_fn}".format(
        out_sam=out_sam, cfg_fn=cfg_fn)
    return cx + ' ; ' + ' | '.join([c0, c1, c2, c3])


def sort_index_chain_bam_cmd(in_sam, out_bam, cfg, tmp_dir):
    """ Sort and index chain bam"""
    cfg, tmp_dir = get_config_and_tmp_dir(cfg, tmp_dir)
    c0 = "samtools sort --threads {nproc} -T {tmp_dir}/srt {in_sam} -o {out_bam}".format(
        nproc=cfg.nproc, tmp_dir=tmp_dir, in_sam=in_sam, out_bam=out_bam)
    c1 = "samtools index {out_bam}".format(out_bam=out_bam)
    return " ; ".join([c0, c1])


def svcall_cmd(ref_fn, in_bam, out_bed, cfg):
    """pbsv1 call"""
    cfg = get_config(cfg)
    assert cfg.cfg_fn is not None
    c0 = "pbsv1 call {ref_fn} {in_bam} {out_bed} --cfg_fn {cfg_fn}".format(
        ref_fn=ref_fn, in_bam=in_bam, out_bed=out_bed, cfg_fn=cfg.cfg_fn)
    return c0


def svalign_cmds(ref_fn, in_fn, out_bam, cfg, tmp_dir, svf, movienames2samples_json):
    """Decomposite `pbsv1 align` to commands"""
    if not (is_bam(in_fn) or is_subreadset(in_fn)):
        raise ValueError("Illegal input file {}: only Pacbio BAM (.bam) or SubreadSet (.subreadset.xml) are supported.".format(in_fn))
    c0 = map_subreads_cmd(in_bam=in_fn, ref_fn=ref_fn, out_bam=svf.ngmlr_bam, cfg=cfg)
    c1 = markdup_cmd(in_bam=svf.ngmlr_bam,
                     out_bam=svf.markdup_bam,
                     template_bam=in_fn,
                     cfg=cfg,
                     movienames2samples_json=movienames2samples_json,
                     tmp_dir=tmp_dir)
    c2 = chain_cmd(in_bam=svf.markdup_bam, out_sam=svf.chain_sam, cfg=cfg, tmp_dir=tmp_dir)
    c3 = sort_index_chain_bam_cmd(
        in_sam=svf.chain_sam, out_bam=svf.sorted_chain_bam, cfg=cfg, tmp_dir=tmp_dir)
    c4 = mv_cmd(svf.sorted_chain_bam, out_bam)
    c5 = mv_cmd(bai_of_bam(svf.sorted_chain_bam), bai_of_bam(out_bam))
    c6 = mv_cmd(transpaths_of_bam(svf.chain_sam), transpaths_of_bam(out_bam))
    return [c0, c1, c2, c3, c4, c5, c6]


def _mkdir(path):
    if not op.isdir(path):
        os.makedirs(path)


def svalign(ref_fn, in_fn, out_bam, cfg, tmp_dir=None, movienames2samples_json=None):
    """pbsv1 align
    If tmp_dir is None, it must be supplied in cfg.
    cfg is a filename or SVConfigData object.
    """
    cfg, tmp_dir = get_config_and_tmp_dir(cfg, tmp_dir)
    tmp_dir = _mktemp_with_user_pid(tmp_dir, 'pbsv.align.XXXXXXXX')

    make_cfg_fn(cfg, op.join(tmp_dir, 'svrun.cfg'))
    svf = SVFiles(tmp_dir)

    cmds = svalign_cmds(ref_fn=ref_fn, in_fn=in_fn,
                        out_bam=out_bam, cfg=cfg, tmp_dir=tmp_dir, svf=svf,
                        movienames2samples_json=movienames2samples_json)
    execute_as_bash(cmds, op.join(tmp_dir, 'svalign.sh'))
