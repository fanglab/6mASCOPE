"""
basic functions for making tool contract parser, running tool contract.
"""
from __future__ import absolute_import

import logging
import os
import re
from collections import namedtuple

from pbcommand.cli import pbparser_runner
from pbcommand.utils import setup_log
from pbcommand.models import get_pbparser, get_scatter_pbparser, get_gather_pbparser, FileTypes, ResourceTypes, SymbolTypes
from pbcommand.pb_io.common import load_pipeline_chunks_from_json
from pbcoretools.chunking.gather import get_datum_from_chunks_by_chunk_key

from pbsv1.ngmlrmap import ln_cmd
from pbsv1.independent.utils import execute

from pbsvtools import get_tool_id, get_driver_exe, get_version, get_tcp_option_name

log = logging.getLogger(__name__)


TCP_INPUT = namedtuple('TCP_INPUT', ['file_type', 'file_id', 'name', 'description'])
TCP_OUTPUT = namedtuple('TCP_OUTPUT', ['file_type', 'file_id', 'name', 'description', 'default_name'])


def all_items_have_attrs(items, attrs):
    """Return True if all items has all attributes, otherwise, False"""
    for item in items:
        for attr in attrs:
            if not hasattr(item, attr):
                return False
    return True


class BaseConstants(object):
    """Class defining all constants needed for a pbsvtools tool contract.
    Concrete class MUST redefine: TOOL_NAME, DESCRIPTION, INPUT_FILES, OUTPUT_FILES
    Optionally redefine: NPROC, PARAMS.
    """
    TOOL_NAME = "unknown"
    DESCRIPTION = "unknown"
    INPUT_FILES = []
    OUTPUT_FILES = []
    NPROC = SymbolTypes.MAX_NPROC
    PARAMS = []
    VERSION = get_version()

    @classmethod
    def TOOL_ID(cls):
        """pbsvtools.tasks.{tool_name}"""
        return get_tool_id(cls.TOOL_NAME)

    @classmethod
    def DRIVER_EXE(cls):
        """python -m pbsvtools.tasks.{tool_name}"""
        return get_driver_exe(cls.TOOL_NAME)

    @classmethod
    def sanity_check(cls):
        """Sanity check class"""
        assert str(cls)
        pattern = re.compile(r"^([a-z])([a-z0-9_])+$")
        if pattern.match(cls.TOOL_NAME) is None:
            raise ValueError("TOOL_NAME %r must match pattern %r" % (cls.TOOL_NAME, pattern))
        if not cls.TOOL_ID().startswith("pbsvtools.tasks."):
            raise ValueError("TOOL_ID %r must starts with pbsvtools.tasks." % cls.TOOL_ID())
        if not cls.DRIVER_EXE().startswith("python -m pbsvtools.tasks."):
            raise ValueError("DIRVER_EXE %r must starts with python -m pbsvtools.tasks." % cls.DRIVER_EXE())
        assert all([isinstance(x, TCP_INPUT) for x in cls.INPUT_FILES])
        assert all([isinstance(x, TCP_OUTPUT) for x in cls.OUTPUT_FILES])
        assert all_items_have_attrs(cls.PARAMS, ['type', 'name', 'desc', 'val'])

    @classmethod
    def __str__(cls):
        attrs = ['TOOL_NAME', 'VERSION', 'DESCRIPTION',
                 'NPROC', 'PARAMS', 'INPUT_FILES', 'OUTPUT_FILES']
        msg = ['TOOL_ID: %r' % cls.TOOL_ID(), 'DRIVER_EXE: %r' % cls.DRIVER_EXE()]
        msg = msg.extend(['%s: %r' % (attr, getattr(cls, attr)) for attr in attrs])
        return '\n'.join(msg)


class BaseScatterConstants(BaseConstants):
    """Base Constants for scatter"""
    DEFAULT_NCHUNKS = 24


def get_contract_parser_from_const(const):
    """Get tool contract parser from const.
    const --- Constants
    default_level --- debug leve, e.g., 'INFO', 'DEBUG',
    """
    p = get_pbparser(tool_id=const.TOOL_ID(),
                     version=get_version(),
                     name=const.TOOL_ID(),
                     description=const.DESCRIPTION,
                     driver_exe=const.DRIVER_EXE(),
                     nproc=const.NPROC,
                     resource_types=(ResourceTypes.TMP_DIR,),
                     default_level='DEBUG')
    add_io_args_const_to_tcp(tcp=p.tool_contract_parser, const=const, arg_parser=p.arg_parser.parser)
    return p


def get_scatter_parser_from_const(const):
    """Get scatter contract parser from const."""
    p = get_scatter_pbparser(tool_id=const.TOOL_ID(),
                             version=const.VERSION,
                             name=const.TOOL_ID(),
                             description=const.DESCRIPTION,
                             driver_exe=const.DRIVER_EXE(),
                             chunk_keys=const.CHUNK_KEYS,
                             default_level='DEBUG')
    add_io_args_const_to_tcp(p, const, p.arg_parser.parser)
    # alway add max nchunks for scatter parsers
    p.add_int("pbsmrtpipe.task_options.dev_scatter_max_nchunks", "max_nchunks",
              const.DEFAULT_NCHUNKS, "Max NChunks", "Maximum number of Chunks")
    return p


def add_io_args_const_to_tcp(tcp, const, arg_parser=None):
    """Add io and options defined in const to tcp"""
    for f in const.INPUT_FILES:
        tcp.add_input_file_type(f.file_type, f.file_id, f.name, f.description)
        if arg_parser:
            arg_parser.add_argument(f.file_id, type=str, help=f.description)

    for f in const.OUTPUT_FILES:
        tcp.add_output_file_type(f.file_type, f.file_id, f.name, f.description, f.default_name)
        if arg_parser:
            arg_parser.add_argument(f.file_id, type=str, help=f.description)

    tcp = add_tcp_parser_options(tcp, params=const.PARAMS, arg_parser=arg_parser)
    if arg_parser:
        arg_parser.add_argument("--nproc", type=int, default=1, help="Number of threads")
    return tcp


def __get_tcp_parser_add_arg_func(p, param):
    """
    return tcp add arg function based on param type
    p --- tcp parser
    param --- pbsv.Constant.PARAM
    """
    if param.type is float:
        return p.add_float
    if param.type is int:
        return p.add_int
    if param.type is bool:
        return p.add_bool
    if param.type is str:
        return p.add_str
    raise ValueError("Could not get add_type function for type %s" % param.type)


def __add_tcp_parser_option(p, param):
    """Add a param as an option to tcp parser
    p --- tcp parser
    param --- pbsv.Constant.PARAM
    """
    option_id = get_tcp_option_name(param.name)
    log.info('option_id is %s', option_id)
    if param.type is list:
        p = p.add_choice_str(option_id=option_id, option_str=param.name, name=param.display_name,
                             default=param.val, description=param.desc, choices=param.choices)
    else:
        p = __get_tcp_parser_add_arg_func(p, param)(option_id=option_id, option_str=param.name,
                                                    name=param.display_name, default=param.val, description=param.desc)
    return p


def add_tcp_parser_options(p, params, arg_parser=None):
    """Add configurable params as options to tcp parser
    e.g., params = ['svlength'] --> tcp.task.options['pbsvtools.task_options.svlength']
    """
    for param in params:
        __add_tcp_parser_option(p, param)
        if arg_parser:
            arg_parser.add_argument("--" + param.name, type=param.type, default=param.val, help=param.desc)
    return p


def args_runner(args):
    """args runner"""
    raise NotImplementedError()


def main(args, const, rtc_runner, alog, args_runner=args_runner):
    """Main"""
    const.sanity_check()
    return pbparser_runner(argv=args,
                           parser=get_contract_parser_from_const(const),
                           args_runner_func=args_runner,
                           contract_runner_func=rtc_runner,
                           alog=alog,
                           setup_log_func=setup_log)


def scatter_main(args, const, rtc_runner, alog, args_runner=args_runner):
    """Scatter main"""
    const.sanity_check()
    return pbparser_runner(argv=args,
                           parser=get_scatter_parser_from_const(const),
                           args_runner_func=args_runner,
                           contract_runner_func=rtc_runner,
                           alog=alog,
                           setup_log_func=setup_log)


class BaseGatherConstants(BaseConstants):
    """Base Constants for gather.
    INPUT_FILES for gather must contain exactly one CHUNK.json file.
    OUTPUT_FILES must be defined later.
    """
    DEFAULT_NCHUNKS = 1
    INPUT_FILES = [
        TCP_INPUT(FileTypes.CHUNK, "cjson_in", "Gather CHUNK Json", "Gathered CHUNK Json with chunk key")
    ]


def get_gather_parser_from_const(const):
    """return a pbparser for gather"""
    p = get_gather_pbparser(tool_id=const.TOOL_ID(),
                            version=const.VERSION,
                            name=const.TOOL_ID(),
                            description=const.DESCRIPTION,
                            driver_exe=const.DRIVER_EXE(),
                            is_distributed=True,
                            nproc=const.DEFAULT_NCHUNKS,
                            default_level='DEBUG')
    add_io_args_const_to_tcp(p, const, arg_parser=p.arg_parser.parser)
    return p


def gather_main(args, const, rtc_runner, alog):
    """Gather main"""
    const.sanity_check()
    return pbparser_runner(argv=args,
                           parser=get_gather_parser_from_const(const),
                           args_runner_func=args_runner,
                           contract_runner_func=rtc_runner,
                           alog=alog,
                           setup_log_func=setup_log)


def gather_run_main(chunk_json, chunk_key, gathered_fn, ln_name, gather_func):
    """Get chunk files by chunk_json by chunk_key, call gather_func to gather
    chunk files and output to gathered_fn.
    Finally, make a symlink of gathered output to file with descriptive name
    (ln_name) in the same directory, e.g., ${blala_path}/file.bed --> ${blala_path}/${ln_name}.bed
    """
    chunks = load_pipeline_chunks_from_json(chunk_json)

    # Allow looseness
    if not chunk_key.startswith('$chunk.'):
        chunk_key = '$chunk.' + chunk_key
        log.warn("Prepending chunk key with '$chunk.' to '{f}'".format(f=str(chunk_key)))

    in_files = get_datum_from_chunks_by_chunk_key(chunks, chunk_key)

    log.info("Gathering from chunked files {fns}:".format(fns=', '.join(in_files)))
    log.info("Calling {func} to gather chunked files to {fn}.".format(func=gather_func.__name__, fn=gathered_fn))
    gather_func(in_files, gathered_fn)

    # make a soft link to a descriptive filename
    ln_fn = os.path.join(os.path.dirname(gathered_fn), ln_name + '.' + gathered_fn.split('.')[-1])
    log.info("Making gathered structural variants {f}".format(f=ln_fn))
    execute(ln_cmd(src=gathered_fn, dst=ln_fn))
    return 0
