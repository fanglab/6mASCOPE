"""
Call minimap2 to map input reads in bam|fasta to reference fasta,
and write output to bam.
"""
from __future__ import absolute_import

import logging
import os.path as op
from .independent.utils import is_sam, is_bam, is_xml, is_fasta, is_fasta_gz,\
        execute_as_bash, is_referenceset_xml, rmpath_cmd, execute, ln_cmd, \
        _link_or_make_fai_cmd, cmds2str, _fai
from .utils import get_fa_from_referenceset_or_fa
from pbcore.io import ReferenceSet


log = logging.getLogger()

def _mmi(fa):
    return '{fa}.mmi'.format(fa=fa)

def make_mmi_cmd(fa):
    """Return a minimap2 cmd string to build mmi index.
    """
    return 'minimap2 -x map-pb -d {fa}.mmi {fa}'.format(fa=fa)


def minimap2_map_cmd(in_fn, ref_fa, out_sam_bam, nproc):
    """
    Return a cmd string which calls minimap2 to align input in_fn
    to reference and produce alignments sam. If out_sam_bam is a bam
    file, convert alignments sam to bam.
    """
    mmi = _mmi(ref_fa)
    ref = ref_fa if not op.exists(mmi) else mmi
    options = '-O 5,56 -E 4,1 -z 400,50 -t {nproc}'.format(nproc=nproc) # minimap2 options
    if is_bam(out_sam_bam):
        out_sam = out_sam_bam[0:out_sam_bam.rfind('.')] + '.sam'
        c0 = 'minimap2 -a {options} {ref} {in_fn} > {out_sam}'.format(options=options, ref=ref, in_fn=in_fn, out_sam=out_sam)
        c1 = 'samtools view -bS {out_sam} -o {out_sam_bam}'.format(out_sam=out_sam, out_sam_bam=out_sam_bam)
        return cmds2str([c0, c1])
    elif is_sam(out_sam_bam):
        c0 = 'minimap2 -a {options} {ref} {in_fn} > {out_sam}'.format(options=options, ref=ref, in_fn=in_fn, out_sam=out_sam)
        return c0
    else:
        raise ValueError('Output file {} be SAM/BAM'.format(out_sam_bam))


def _link_or_make_mmi_cmd(in_mmi, out_fa):
    assert in_mmi.endswith('.mmi')
    if op.exists(in_mmi): # if in_mmi exists, make a link
        log.info("mmi index file %s exists, make symbolic links" % (in_mmi))
        return ln_cmd(src=in_mmi, dst=(out_fa + '.mmi'))
    else: # not exist, call `minimap2 -d ` to make mmi.
        log.info("Generate mmi index for file %s" % (out_fa))
        return make_mmi_cmd(fa=out_fa)


def prepare_minimap2_reference_cmd(in_fa, out_fa):
    """Return a cmd string to copy or symlink fa, fai, mmi indices."""
    in_fai, in_mmi = _fai(in_fa), _mmi(in_fa)
    out_fai, out_mmi = _fai(out_fa), _mmi(out_fa)
    cmds = [ln_cmd(src=in_fa, dst=out_fa), # fa
            _link_or_make_fai_cmd(in_fai=in_fai, out_fa=out_fa), # fai
            make_mmi_cmd(out_fa)] # mmi
    return cmds2str(cmds)


def minimap2_map(in_fn, ref_fn, out_bam, nproc=4):
    """
    Call minimap2 to map in.fa or in.bam to reference fasta.
    ref_fn --- reference in referenceset or fasta
    """
    ref_fa = get_fa_from_referenceset_or_fa(ref_fn)
    if is_bam(in_fn) or is_xml(in_fn):
        out_prefix = out_bam[0:out_bam.rfind('.')] + '.query'
        out_fasta_gz = '{out_prefix}.fasta.gz'.format(out_prefix=out_prefix)
        log.debug('Converting {in_fn} to {out_fasta_gz}'.format(in_fn=in_fn, out_fasta_gz=out_fasta_gz))
        cmd = 'bam2fasta {in_fn} -o {out_prefix}'.format(in_fn=in_fn, out_prefix=out_prefix)
        execute(cmd)
        in_fn = out_fasta_gz # reset in_fn from bam/xml to fasta.gz
    if is_fasta(in_fn) or is_fasta_gz(in_fn): # minimap2 takes fasta/fasta.gz inputs
        cmd = minimap2_map_cmd(in_fn=in_fn, ref_fa=ref_fa, out_sam_bam=out_bam, nproc=nproc)
        execute(cmd)
    else:
        raise ValueError("{!r} is neither bam nor fasta".format(in_fn))
