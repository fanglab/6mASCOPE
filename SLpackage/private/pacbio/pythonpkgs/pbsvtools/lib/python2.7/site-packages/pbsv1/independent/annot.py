"""Annotate structural variant calls."""
from __future__ import absolute_import
from __future__ import division
import os.path as op

from .FastaReader import read_fasta
from .utils import count_kmers, kmertopos, revcomp, find_best_kmer_diagonal, is_tandem_repeat
from .common import SvAnnotations
from .repeats import REPEATS_CONTENT
from cStringIO import StringIO


# List of important public functions.
#__all__ = ['REPEATS', 'annot_seq']


class Repeat(object):
    """Provide methods to match against a repeat consensus."""
    def __init__(self, name, consensus):
        self.name = name
        self.consensus = consensus.upper()
        self.consensuslen = len(consensus)

        # Create a kmer to position map for the repeat and its reverse complement.
        self._k = 6
        self._kmerposforward = kmertopos(self._k, self.consensus)
        self._kmerposreverse = kmertopos(self._k, revcomp(self.consensus))


    def match(self, seq, max_len_extend_percentage=0.5, min_shared_kmer_percentage=0.3):
        """Determine if a sequence matches the repeat consensus
        using a chained kmer alignment approximation.  Full sequence
        to consensus alignment is slow, and matching does not require
        the actual alignment, only a classification as match / non-match.
        So, instead look for a diagonal in which a specified fraction of
        the sequence's bases are in kmer matches to the repeat consensus.
        """
        k = self._k
        if len(seq) < k or self.consensuslen < k:
            return False
        seqlen = len(seq)
        matchforward, matchreverse = False, False

        assert 0.0 <= max_len_extend_percentage <= 1.0

        min_len = (1 - max_len_extend_percentage) * self.consensuslen
        max_len = (1 + max_len_extend_percentage) * self.consensuslen
        if min_len < seqlen < max_len:
            seqkmerpos = kmertopos(k, seq.upper())

            # Find the highest number of `seq` basepairs in kmer matches in a single diagonal.
            bandwidth = 25
            shared_kmerbp_forward = find_best_kmer_diagonal(seqkmerpos, self._kmerposforward, bandwidth)
            shared_kmerbp_reverse = find_best_kmer_diagonal(seqkmerpos, self._kmerposreverse, bandwidth)

            # consider the sequence a match if the number of shared kmers is sufficiently high
            matchforward = (shared_kmerbp_forward/max(self.consensuslen, seqlen)) > min_shared_kmer_percentage
            matchreverse = (shared_kmerbp_reverse/max(self.consensuslen, seqlen)) > min_shared_kmer_percentage

        return matchforward or matchreverse


def _fasta2repeats(ifs):
    """Convert content to a list of Repeat objects"""
    return [Repeat(name, consensus) for (name, consensus) in read_fasta(ifs)]


# Load seqs of repeats from data/repeats.fasta
# Create a kmer map for each repeat (and its reverse complement).
REPEATS = _fasta2repeats(StringIO(REPEATS_CONTENT))


def annot_seq(seq, repeats=REPEATS):
    """Annotate seq by comparing with repeats and return SvAnnotations"""
    annotations = set()
    # Annotate against known repeats.
    for repeat in repeats:
        if repeat.match(seq):
            annotations.add(repeat.name)
    # Test whether the sequence is a tandem repeat (has many repeated kmers).
    if len(annotations) == 0 and is_tandem_repeat(seq):
        annotations.add("TANDEM")
    if len(annotations) == 0:
        annotations.add("OTHER")
    return SvAnnotations(annotations=sorted(annotations))

''' UNUSED
def annot_bed_fn(in_bed, out_bed, repeats_fa=None):
    """Annotate SVs in in_bed by mapping to repeats in REPEATS_FN,
    and output to out_bed.
    """
    if repeats_fa is None:
        repeats = REPEATS
    else:
        with open(repeats_fa) as ifs:
            repeats = _fasta2repeats(ifs)
    with BedReader(in_bed) as reader, BedWriter(out_bed) as writer:
        for record in reader: # Annotate each SV.
            record.annotations = annot_seq(record.seq, repeats)
            writer.writeRecord(record)
'''
