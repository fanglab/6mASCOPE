"""Utility for reading and writing line-based text files inspired by the
similarly-named utility from the Kent source.

A linefile supports "-", "stdin", and "stdout" as file names and auto-detects
file compression from file extension.
"""
from __future__ import absolute_import

import io
import gzip
import bz2
import sys

from pbcore.io import SubreadSet, ContigSet, FastaRecord, BamAlignment
from ..independent.utils import autofmt

try:
    import builtins
except ImportError:
    import __builtin__ as builtins


# List of important public functions.
#__all__ = ['x2fasta', 'X2PysamReader']


class LineFile(io.TextIOBase):

    """A linefile, which provides convenience methods for reading and writing
    line-based text files.
    """

    def __init__(self, stream, filename, comment_prefix, skip_comments, skip_blanks):
        """Stash the underlying stream used for reading/writing."""
        self._stream = stream
        self.filename = filename
        self._comment_prefix = comment_prefix
        self._skip_comments = skip_comments
        self._skip_blanks = skip_blanks
        self._last = None
        self._reuse = False

    def readline(self):
        """Read a single line from the linefile."""

        def next_line():
            """read next line"""
            if self._reuse:
                self._reuse = False
                self._last = self._last if (self._last is not None) else self._stream.readline()
            else:
                self._last = self._stream.readline()

            return self._last

        def is_good_line(s):
            """Is this a good line"""
            return not(self._skip_blanks and (s == "\n")) and \
                not(self._skip_comments and s.startswith(self._comment_prefix))

        s = next_line()
        while s and not is_good_line(s):
            s = next_line()

        return s

    def read(self):
        """ Read the whole file and return as one string, while respecting all commons and skips """
        return ''.join(list(self))

    def reuse(self):
        """Reuse the previously read line on the next readline()."""
        self._reuse = True

    def write(self, s):
        """Write a string to the linefile."""
        self._stream.write(s)

    def close(self):
        """Close the linefile."""
        if self._stream not in [sys.stdin, sys.stdout]:
            self._stream.close()


def open(f, mode=None, comment_prefix="#", skip_comments=True, skip_blanks=True):
    """Open a line-based text file, with auto-detection of file compression
    from the file extension (.gz, .bz2).

    f is either a filename or an io.TextIOBase stream.
    """
    mode = "r" if mode is None else mode  # default mode is "r"
    if mode not in ["r", "w", "a"]:
        raise ValueError("invalid linefile mode: '%s'" % (mode))

    # open the stream with the appropriate reader
    stream = None
    if isinstance(f, str):
        filename = f
        if f == "stdin":
            stream = sys.stdin
        elif f == "stdout":
            stream = sys.stdout
        elif f == "-":
            stream = sys.stdin if mode == "r" else sys.stdout
        elif f.endswith(".gz") or f.endswith(".Z") or f.endswith(".zip"):
            stream = io.TextIOWrapper(gzip.open(f, mode, compresslevel=6))
        elif f.endswith(".bz2"):
            stream = io.TextIOWrapper(bz2.BZ2File(f, mode))
        else:
            stream = builtins.open(f, mode)
    else:
        filename = None
        stream = f

    return LineFile(stream=stream, filename=filename,
                    comment_prefix=comment_prefix,
                    skip_comments=skip_comments, skip_blanks=skip_blanks)


class X2YReaderBase(object):

    """Read X as if it was Y"""

    valid_infmt = ("bam", "sam", "contigset.xml", "subreadset.xml", "alignmentset.xml", "fofn", "json")

    def __init__(self, fn):
        # valid input format
        self.fn, self.fmt = autofmt(fn, self.valid_infmt, None)
        self._reader = None

    def __iter__(self):
        """Iterators over records."""
        for r in self._reader:
            yield self.x2y(r)

    def x2y(self, r):
        """Convert object x to y"""
        raise NotImplementedError()

    def __repr__(self):
        return "<%s of files: %s>" % (self.__class__.__name__, self.fn)

    def close(self):
        """Close all readers"""
        self._reader.close()

    def __enter__(self):
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        return self.close()


class X2FastaReader(X2YReaderBase):
    """
    Read input file and yield fasta.

    If input file is .subreadset.xml or .contigset.xml, iterates
    over reads and yield as if input was fasta.

    If input is -/stdin/stdout/.gz/.Z/.zip/bz2, iterates
    over each line of the file.
    """
    def __init__(self, fn):
        super(X2FastaReader, self).__init__(fn)
        if self.fmt == 'subreadset.xml':
            self._reader = SubreadSet(self.fn)
        elif self.fmt == 'contigset.xml':
            self._reader = ContigSet(self.fn)
        else:
            self._reader = open(self.fn, mode='r', skip_comments=True, skip_blanks=True)

    def x2y(self, x):
        """Concert BamAlignment/FastaRecord/line to Fasta"""
        if isinstance(x, BamAlignment):
            return '>%s\n%s\n' % (x.readName, x.read(False))
        elif isinstance(x, FastaRecord):
            return '>%s\n%s\n' % (x.name, x.sequence)
        else: # as is
            return x


def x2fasta(input_files, output_file):
    """Read all files in input_files and write as fasta to output_file."""
    with open(output_file, 'w') as writer:
        for f in input_files:
            with X2FastaReader(f) as x2:
                for line in x2:
                    writer.write(line)
