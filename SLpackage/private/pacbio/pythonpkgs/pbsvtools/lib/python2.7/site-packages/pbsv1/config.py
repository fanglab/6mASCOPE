"""
Class svconfig defines parameters for structural varation tools.
"""
from __future__ import absolute_import

import logging
import ConfigParser
import shutil
import StringIO
import traceback

from .independent.utils import realpath, str2bool
from .Constants import MARKDUP_PARAMS, CHAIN_PARAMS, SGE_PARAMS, SVCALL_PARAMS, ALIGN_PARAMS

log = logging.getLogger()


__all__ = []

def svconfig_write(svconfig, writer):
    """Write SVConfig to writer.
    """
    man = SVConfigManipulator()
    man.write(svconfig, writer)

class SVConfigData(object):
    """This has as few extraneous attributes as possible.
    """
    def __init__(self):
        # pylint wants to see actual attrs
        self.nproc = None
        self.tmp_dir = None
        self.chain_min_mapq = None
        self.chain_max_gap = None
        self.inversion_poswiggle = None
        self.cfg_fn = None


def SVConfig(cfg_fn = None):
    """Return SVConfigData

    Usage:
        c = SVConfig('a.cfg')
        c.nproc == 4
        c.nproc = 5
        write_svconfig(c, open('b.cfg'))
    """
    creator = SVConfigManipulator()
    svconfig = creator.create_default()
    if cfg_fn is not None:
        cfg_fn = realpath(cfg_fn)
        log.debug('Reading Config from {!r}'.format(cfg_fn))
        with open(cfg_fn) as reader:
            svconfig = creator.update(svconfig, reader)
        svconfig.cfg_fn = cfg_fn
    return svconfig


class SVConfigManipulator(object):
    # default parameters of sections
    SECTIONS = {"markdup": MARKDUP_PARAMS, "chain": CHAIN_PARAMS,
                "call": SVCALL_PARAMS, "sge": SGE_PARAMS,
                'align': ALIGN_PARAMS}

    @classmethod
    def create_default(cls):
        svconfig = SVConfigData()
        writer = StringIO.StringIO()
        cls._write_default_cfg(writer)
        cfg_content = writer.getvalue()
        reader = StringIO.StringIO(cfg_content)
        cls._update_from_config(svconfig.__dict__, reader)
        return svconfig

    @classmethod
    def update(cls, svconfig, cfgfp):
        """Given SVConfig and ConfigParser-file-reader, update and return SVConfig.
        """
        cls._update_from_config(svconfig.__dict__, cfgfp)
        return svconfig

    @classmethod
    def _write_default_cfg(cls, writer):
        """Write a ConfigParser file, based on defaults in SECTIONS.
        """
        for section, params in cls.SECTIONS.iteritems():
            writer.write('[{}]\n'.format(section))
            for param in params:
                writer.write('{} = {}\n'.format(param.name, param.val))

    @classmethod
    def _update_from_config(cls, param_dict, reader):
        cfg = ConfigParser.ConfigParser()
        cfg.readfp(reader)
        for section in cfg.sections():
            if not cls._is_section(section):
                log.warning("Ignore unexpected section %s.", section)
            else:
                for name, val in cfg.items(section):
                    if cls._is_param(name, section):
                        param_dict[name] = cls._convert_param_val(name, val)
                    else:
                        log.warning("%s is not a valid param of section %s", name, section)

    @classmethod
    def _convert_param_val(cls, name, val_from_cfg):
        try:
            type = cls._get_param_type(name)
            if type == bool:
                return str2bool(val_from_cfg)
            else:
                return type(val_from_cfg)
        except Exception:
            raise ValueError('%s\nCould not convert %r to %r' % (traceback.format_exc(), val_from_cfg, type))

    @classmethod
    def _is_section(cls, section):
        """is section valid"""
        return section.lower() in [s.lower() for s in cls.SECTIONS.keys()]

    @classmethod
    def _get_default_param(cls, name):
        """Return default param of name"""
        for params in cls.SECTIONS.values(): # pragma: no cover
            for param in params:
                if name.lower() == param.name.lower():
                    return param
        # unreachable #raise ValueError("%s is not a valid param" % name)

    @classmethod
    def _get_param_type(cls, name):
        """Return type of parameter of name"""
        return cls._get_default_param(name).type

    @classmethod
    def _is_param(cls, name, section):
        """Return True if name is a valid param name in section.
        """
        assert section in cls.SECTIONS
        return any([name.lower() == param.name.lower() for param in cls.SECTIONS[section]])

    def to_str(self, svconfig):
        ret = []
        for section in sorted(self.SECTIONS.keys()):
            ret.append("[%s]" % section)
            for param in self.SECTIONS[section]:
                ret.extend(['# %s, type=%r' % (param.desc, param.type),
                            '%s=%s' % (param.name, getattr(svconfig, param.name))])
            ret.append("")
        return '\n'.join(ret)

    def write(self, svconfig, writer):
        """Write cfg to output-file-stream writer.
        """
        writer.write(self.to_str(svconfig))

def reset_cfg_nproc(svconfig, nproc):
    """Reset nproc in a cfg obj"""
    svconfig.nproc = int(nproc)
    svconfig.cfg_fn = None # also reset associated cfg_fn

def make_cfg_fn(svconfig, o_cfg_fn):
    """Reset self.cfg_fn to o_cfg_fn"""
    if svconfig.cfg_fn is None:
        with open(o_cfg_fn, 'w') as writer:
            SVConfigManipulator().write(svconfig, writer)
    else:
        shutil.copy(svconfig.cfg_fn, o_cfg_fn)
    svconfig.cfg_fn = o_cfg_fn


def get_config(cfg):
    """wrapper, converts either a cfg fn or a SVConfig obj to SVConfig obj"""
    if isinstance(cfg, str):
        cfg = SVConfig(cfg)
    elif not isinstance(cfg, SVConfigData):
        raise ValueError(
            "cfg must be either SVConfigData obj or a config filename")
    log.debug("config: %s", str(cfg))
    return cfg


def get_config_and_tmp_dir(cfg, tmp_dir):
    """Return cfg object and tmp_dir.
    If tmp_dir is None, use cfg.tmp_dir; otherwise, use tmp_dir
    """
    cfg = get_config(cfg)
    if tmp_dir is None:
        return cfg, cfg.tmp_dir
    else:
        assert isinstance(tmp_dir, str)
        return cfg, tmp_dir
